(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var errors_1 = require('./errors');
var promise_1 = require('./promise');
/**
 * @hidden
 */
var AuthTokenContext = (function () {
    function AuthTokenContext(deps, label) {
        this.label = label;
        this.storage = deps.storage;
    }
    AuthTokenContext.prototype.get = function () {
        return this.storage.get(this.label);
    };
    AuthTokenContext.prototype.store = function (token) {
        this.storage.set(this.label, token);
    };
    AuthTokenContext.prototype.delete = function () {
        this.storage.delete(this.label);
    };
    return AuthTokenContext;
}());
exports.AuthTokenContext = AuthTokenContext;
/**
 * @hidden
 */
var CombinedAuthTokenContext = (function () {
    function CombinedAuthTokenContext(deps, label) {
        this.label = label;
        this.storage = deps.storage;
        this.tempStorage = deps.tempStorage;
    }
    CombinedAuthTokenContext.prototype.get = function () {
        var permToken = this.storage.get(this.label);
        var tempToken = this.tempStorage.get(this.label);
        var token = tempToken || permToken;
        return token;
    };
    CombinedAuthTokenContext.prototype.store = function (token, options) {
        if (options === void 0) { options = { 'permanent': true }; }
        if (options.permanent) {
            this.storage.set(this.label, token);
        }
        else {
            this.tempStorage.set(this.label, token);
        }
    };
    CombinedAuthTokenContext.prototype.delete = function () {
        this.storage.delete(this.label);
        this.tempStorage.delete(this.label);
    };
    return CombinedAuthTokenContext;
}());
exports.CombinedAuthTokenContext = CombinedAuthTokenContext;
/**
 * `Auth` handles authentication of a single user, such as signing up, logging
 * in & out, social provider authentication, etc.
 *
 * @featured
 */
var Auth = (function () {
    function Auth(deps, 
        /**
         * @hidden
         */
        options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.config = deps.config;
        this.emitter = deps.emitter;
        this.authModules = deps.authModules;
        this.tokenContext = deps.tokenContext;
        this.userService = deps.userService;
        this.storage = deps.storage;
    }
    Object.defineProperty(Auth.prototype, "passwordResetUrl", {
        /**
         * Link the user to this URL for password resets. Only for email/password
         * authentication.
         *
         * Use this if you want to use our password reset forms instead of creating
         * your own in your app.
         */
        get: function () {
            return this.config.getURL('web') + "/password/reset/" + this.config.get('app_id');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Check whether the user is logged in or not.
     *
     * If an auth token exists in local storage, the user is logged in.
     */
    Auth.prototype.isAuthenticated = function () {
        var token = this.tokenContext.get();
        if (token) {
            return true;
        }
        return false;
    };
    /**
     * Sign up a user with the given data. Only for email/password
     * authentication.
     *
     * `signup` does not affect local data or the current user until `login` is
     * called. This means you'll likely want to log in your users manually after
     * signup.
     *
     * If a signup fails, the promise rejects with a [`IDetailedError`
     * object](/api/client/idetailederror) that contains an array of error codes
     * from the cloud.
     *
     * @param details - The details that describe a user.
     */
    Auth.prototype.signup = function (details) {
        return this.authModules.basic.signup(details);
    };
    /**
     * Attempt to log the user in with the given credentials. For custom & social
     * logins, kick-off the authentication process.
     *
     * After login, the full user is loaded from the cloud and saved in local
     * storage along with their auth token.
     *
     * @note TODO: Better error handling docs.
     *
     * @param moduleId
     *  The authentication provider module ID to use with this login.
     * @param credentials
     *  For email/password authentication, give an email and password. For social
     *  authentication, exclude this parameter. For custom authentication, send
     *  whatever you need.
     * @param options
     *  Options for this login, such as whether to remember the login and
     *  InAppBrowser window options for authentication providers that make use of
     *  it.
     */
    Auth.prototype.login = function (moduleId, credentials, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (typeof options.remember === 'undefined') {
            options.remember = true;
        }
        if (typeof options.inAppBrowserOptions === 'undefined') {
            options.inAppBrowserOptions = {};
        }
        if (typeof options.inAppBrowserOptions.location === 'undefined') {
            options.inAppBrowserOptions.location = false;
        }
        if (typeof options.inAppBrowserOptions.clearcache === 'undefined') {
            options.inAppBrowserOptions.clearcache = true;
        }
        if (typeof options.inAppBrowserOptions.clearsessioncache === 'undefined') {
            options.inAppBrowserOptions.clearsessioncache = true;
        }
        var context = this.authModules[moduleId];
        if (!context) {
            throw new Error('Authentication class is invalid or missing:' + context);
        }
        return context.authenticate(credentials, options).then(function (r) {
            _this.storeToken(options, r.token);
            return _this.userService.load().then(function () {
                var user = _this.userService.current();
                user.store();
                return r;
            });
        });
    };
    /**
     * Log the user out of the app.
     *
     * This clears the auth token out of local storage and restores the user to
     * an unauthenticated state.
     */
    Auth.prototype.logout = function () {
        this.tokenContext.delete();
        var user = this.userService.current();
        user.unstore();
        user.clear();
    };
    /**
     * Kick-off the password reset process. Only for email/password
     * authentication.
     *
     * An email will be sent to the user with a short password reset code, which
     * they can copy back into your app and use the [`confirmPasswordReset()`
     * method](#confirmPasswordReset).
     *
     * @param email - The email address to which to send a code.
     */
    Auth.prototype.requestPasswordReset = function (email) {
        this.storage.set('auth_password_reset_email', email);
        return this.authModules.basic.requestPasswordReset(email);
    };
    /**
     * Confirm a password reset.
     *
     * When the user gives you their password reset code into your app and their
     * requested changed password, call this method.
     *
     * @param code - The password reset code from the user.
     * @param newPassword - The requested changed password from the user.
     */
    Auth.prototype.confirmPasswordReset = function (code, newPassword) {
        var email = this.storage.get('auth_password_reset_email');
        return this.authModules.basic.confirmPasswordReset(email, code, newPassword);
    };
    /**
     * Get the raw auth token of the active user from local storage.
     */
    Auth.prototype.getToken = function () {
        return this.tokenContext.get();
    };
    /**
     * @hidden
     */
    Auth.prototype.storeToken = function (options, token) {
        if (options === void 0) { options = { 'remember': true }; }
        var originalToken = this.authToken;
        this.authToken = token;
        this.tokenContext.store(this.authToken, { 'permanent': options.remember });
        this.emitter.emit('auth:token-changed', { 'old': originalToken, 'new': this.authToken });
    };
    /**
     * @hidden
     */
    Auth.getDetailedErrorFromResponse = function (res) {
        var errors = [];
        var details = [];
        try {
            details = res.body.error.details;
        }
        catch (e) { }
        for (var i = 0; i < details.length; i++) {
            var detail = details[i];
            if (detail.error_type) {
                errors.push(detail.error_type + '_' + detail.parameter);
            }
        }
        return new errors_1.DetailedError('Error creating user', errors);
    };
    return Auth;
}());
exports.Auth = Auth;
/**
 * @hidden
 */
var AuthType = (function () {
    function AuthType(deps) {
        this.config = deps.config;
        this.client = deps.client;
    }
    AuthType.prototype.parseInAppBrowserOptions = function (opts) {
        if (!opts) {
            return '';
        }
        var p = [];
        for (var k in opts) {
            var v = void 0;
            if (typeof opts[k] === 'boolean') {
                v = opts[k] ? 'yes' : 'no';
            }
            else {
                v = opts[k];
            }
            p.push(k + "=" + v);
        }
        return p.join(',');
    };
    AuthType.prototype.inAppBrowserFlow = function (moduleId, data, options) {
        var _this = this;
        if (data === void 0) { data = {}; }
        var deferred = new promise_1.DeferredPromise();
        if (!window || !window.cordova || !window.cordova.InAppBrowser) {
            deferred.reject(new Error('InAppBrowser plugin missing'));
        }
        else {
            this.client.post("/auth/login/" + moduleId)
                .send({
                'app_id': this.config.get('app_id'),
                'callback': window.location.href,
                'data': data
            })
                .end(function (err, res) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    var w_1 = window.cordova.InAppBrowser.open(res.body.data.url, '_blank', _this.parseInAppBrowserOptions(options.inAppBrowserOptions));
                    var onExit_1 = function () {
                        deferred.reject(new Error('InAppBrowser exit'));
                    };
                    var onLoadError_1 = function () {
                        deferred.reject(new Error('InAppBrowser loaderror'));
                    };
                    var onLoadStart = function (data) {
                        if (data.url.slice(0, 20) === 'http://auth.ionic.io') {
                            var queryString = data.url.split('#')[0].split('?')[1];
                            var paramParts = queryString.split('&');
                            var params = {};
                            for (var i = 0; i < paramParts.length; i++) {
                                var part = paramParts[i].split('=');
                                params[part[0]] = part[1];
                            }
                            w_1.removeEventListener('exit', onExit_1);
                            w_1.removeEventListener('loaderror', onLoadError_1);
                            w_1.close();
                            deferred.resolve({
                                'token': params['token'],
                                'signup': Boolean(parseInt(params['signup'], 10))
                            });
                        }
                    };
                    w_1.addEventListener('exit', onExit_1);
                    w_1.addEventListener('loaderror', onLoadError_1);
                    w_1.addEventListener('loadstart', onLoadStart);
                }
            });
        }
        return deferred.promise;
    };
    return AuthType;
}());
exports.AuthType = AuthType;
/**
 * @hidden
 */
var BasicAuth = (function (_super) {
    __extends(BasicAuth, _super);
    function BasicAuth() {
        _super.apply(this, arguments);
    }
    BasicAuth.prototype.authenticate = function (data, options) {
        var deferred = new promise_1.DeferredPromise();
        if (!data.email || !data.password) {
            deferred.reject(new Error('email and password are required for basic authentication'));
        }
        else {
            this.client.post('/auth/login')
                .send({
                'app_id': this.config.get('app_id'),
                'email': data.email,
                'password': data.password
            })
                .end(function (err, res) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    deferred.resolve({
                        'token': res.body.data.token
                    });
                }
            });
        }
        return deferred.promise;
    };
    BasicAuth.prototype.requestPasswordReset = function (email) {
        var deferred = new promise_1.DeferredPromise();
        if (!email) {
            deferred.reject(new Error('Email is required for password reset request.'));
        }
        else {
            this.client.post('/users/password/reset')
                .send({
                'app_id': this.config.get('app_id'),
                'email': email,
                'flow': 'app'
            })
                .end(function (err, res) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    deferred.resolve();
                }
            });
        }
        return deferred.promise;
    };
    BasicAuth.prototype.confirmPasswordReset = function (email, code, newPassword) {
        var deferred = new promise_1.DeferredPromise();
        if (!code || !email || !newPassword) {
            deferred.reject(new Error('Code, new password, and email are required.'));
        }
        else {
            this.client.post('/users/password')
                .send({
                'reset_token': code,
                'new_password': newPassword,
                'email': email
            })
                .end(function (err, res) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    deferred.resolve();
                }
            });
        }
        return deferred.promise;
    };
    BasicAuth.prototype.signup = function (data) {
        var deferred = new promise_1.DeferredPromise();
        var userData = {
            'app_id': this.config.get('app_id'),
            'email': data.email,
            'password': data.password
        };
        // optional details
        if (data.username) {
            userData.username = data.username;
        }
        if (data.image) {
            userData.image = data.image;
        }
        if (data.name) {
            userData.name = data.name;
        }
        if (data.custom) {
            userData.custom = data.custom;
        }
        this.client.post('/users')
            .send(userData)
            .end(function (err, res) {
            if (err) {
                deferred.reject(Auth.getDetailedErrorFromResponse(err.response));
            }
            else {
                deferred.resolve();
            }
        });
        return deferred.promise;
    };
    return BasicAuth;
}(AuthType));
exports.BasicAuth = BasicAuth;
/**
 * @hidden
 */
var CustomAuth = (function (_super) {
    __extends(CustomAuth, _super);
    function CustomAuth() {
        _super.apply(this, arguments);
    }
    CustomAuth.prototype.authenticate = function (data, options) {
        if (data === void 0) { data = {}; }
        return this.inAppBrowserFlow('custom', data, options);
    };
    return CustomAuth;
}(AuthType));
exports.CustomAuth = CustomAuth;
/**
 * @hidden
 */
var TwitterAuth = (function (_super) {
    __extends(TwitterAuth, _super);
    function TwitterAuth() {
        _super.apply(this, arguments);
    }
    TwitterAuth.prototype.authenticate = function (data, options) {
        if (data === void 0) { data = {}; }
        return this.inAppBrowserFlow('twitter', data, options);
    };
    return TwitterAuth;
}(AuthType));
exports.TwitterAuth = TwitterAuth;
/**
 * @hidden
 */
var FacebookAuth = (function (_super) {
    __extends(FacebookAuth, _super);
    function FacebookAuth() {
        _super.apply(this, arguments);
    }
    FacebookAuth.prototype.authenticate = function (data, options) {
        if (data === void 0) { data = {}; }
        return this.inAppBrowserFlow('facebook', data, options);
    };
    return FacebookAuth;
}(AuthType));
exports.FacebookAuth = FacebookAuth;
/**
 * @hidden
 */
var GithubAuth = (function (_super) {
    __extends(GithubAuth, _super);
    function GithubAuth() {
        _super.apply(this, arguments);
    }
    GithubAuth.prototype.authenticate = function (data, options) {
        if (data === void 0) { data = {}; }
        return this.inAppBrowserFlow('github', data, options);
    };
    return GithubAuth;
}(AuthType));
exports.GithubAuth = GithubAuth;
/**
 * @hidden
 */
var GoogleAuth = (function (_super) {
    __extends(GoogleAuth, _super);
    function GoogleAuth() {
        _super.apply(this, arguments);
    }
    GoogleAuth.prototype.authenticate = function (data, options) {
        if (data === void 0) { data = {}; }
        return this.inAppBrowserFlow('google', data, options);
    };
    return GoogleAuth;
}(AuthType));
exports.GoogleAuth = GoogleAuth;
/**
 * @hidden
 */
var InstagramAuth = (function (_super) {
    __extends(InstagramAuth, _super);
    function InstagramAuth() {
        _super.apply(this, arguments);
    }
    InstagramAuth.prototype.authenticate = function (data, options) {
        if (data === void 0) { data = {}; }
        return this.inAppBrowserFlow('instagram', data, options);
    };
    return InstagramAuth;
}(AuthType));
exports.InstagramAuth = InstagramAuth;
/**
 * @hidden
 */
var LinkedInAuth = (function (_super) {
    __extends(LinkedInAuth, _super);
    function LinkedInAuth() {
        _super.apply(this, arguments);
    }
    LinkedInAuth.prototype.authenticate = function (data, options) {
        if (data === void 0) { data = {}; }
        return this.inAppBrowserFlow('linkedin', data, options);
    };
    return LinkedInAuth;
}(AuthType));
exports.LinkedInAuth = LinkedInAuth;

},{"./errors":9,"./promise":14}],2:[function(require,module,exports){
"use strict";
var request = require('superagent');
/**
 * `Client` is for making HTTP requests to the API.
 *
 * Under the hood, it uses
 * [superagent](http://visionmedia.github.io/superagent/). When a method is
 * called, you can call any number of superagent functions on it and then call
 * `end()` to complete and send the request.
 *
 * @featured
 */
var Client = (function () {
    function Client(
        /**
         * @hidden
         */
        tokenContext, 
        /**
         * @hidden
         */
        baseUrl, req // TODO: use superagent types
        ) {
        this.tokenContext = tokenContext;
        this.baseUrl = baseUrl;
        if (typeof req === 'undefined') {
            req = request;
        }
        this.req = req;
    }
    /**
     * GET request for retrieving a resource from the API.
     *
     * @param endpoint - The path of the API endpoint.
     */
    Client.prototype.get = function (endpoint) {
        return this.supplement(this.req.get, endpoint);
    };
    /**
     * POST request for sending a new resource to the API.
     *
     * @param endpoint - The path of the API endpoint.
     */
    Client.prototype.post = function (endpoint) {
        return this.supplement(this.req.post, endpoint);
    };
    /**
     * PUT request for replacing a resource in the API.
     *
     * @param endpoint - The path of the API endpoint.
     */
    Client.prototype.put = function (endpoint) {
        return this.supplement(this.req.put, endpoint);
    };
    /**
     * PATCH request for performing partial updates to a resource in the API.
     *
     * @param endpoint - The path of the API endpoint.
     */
    Client.prototype.patch = function (endpoint) {
        return this.supplement(this.req.patch, endpoint);
    };
    /**
     * DELETE request for deleting a resource from the API.
     *
     * @param endpoint - The path of the API endpoint.
     */
    Client.prototype.delete = function (endpoint) {
        return this.supplement(this.req.delete, endpoint);
    };
    /**
     * @hidden
     */
    Client.prototype.request = function (method, endpoint) {
        return this.supplement(this.req.bind(this.req, method), endpoint);
    };
    /**
     * @private
     */
    Client.prototype.supplement = function (fn, endpoint) {
        if (endpoint.substring(0, 1) !== '/') {
            throw Error('endpoint must start with leading slash');
        }
        var req = fn(this.baseUrl + endpoint);
        var token = this.tokenContext.get();
        if (token) {
            req.set('Authorization', "Bearer " + token);
        }
        return req;
    };
    return Client;
}());
exports.Client = Client;

},{"superagent":22}],3:[function(require,module,exports){
"use strict";
/**
 * @hidden
 */
var Config = (function () {
    function Config() {
        /**
         * @private
         */
        this.urls = {
            'api': 'https://api.ionic.io',
            'web': 'https://web.ionic.io'
        };
    }
    /**
     * Register a new config.
     */
    Config.prototype.register = function (settings) {
        this.settings = settings;
    };
    /**
     * Get a value from the core settings. You should use `settings` attribute
     * directly for core settings and other settings.
     *
     * @deprecated
     *
     * @param name - The settings key to get.
     */
    Config.prototype.get = function (name) {
        if (!this.settings || !this.settings.core) {
            return undefined;
        }
        return this.settings.core[name];
    };
    /**
     * @hidden
     */
    Config.prototype.getURL = function (name) {
        var urls = (this.settings && this.settings.core && this.settings.core.urls) || {};
        if (urls[name]) {
            return urls[name];
        }
        return this.urls[name];
    };
    return Config;
}());
exports.Config = Config;

},{}],4:[function(require,module,exports){
"use strict";
/**
 * @hidden
 */
var Cordova = (function () {
    function Cordova(deps, options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        this.app = deps.appStatus;
        this.device = deps.device;
        this.emitter = deps.emitter;
        this.logger = deps.logger;
        this.registerEventHandlers();
    }
    Cordova.prototype.bootstrap = function () {
        var _this = this;
        var events = ['pause', 'resume'];
        document.addEventListener('deviceready', function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            _this.emitter.emit('cordova:deviceready', { 'args': args });
            var _loop_1 = function(e) {
                document.addEventListener(e, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    _this.emitter.emit('cordova:' + e, { 'args': args });
                }, false);
            };
            for (var _a = 0, events_1 = events; _a < events_1.length; _a++) {
                var e = events_1[_a];
                _loop_1(e);
            }
        }, false);
    };
    /**
     * @private
     */
    Cordova.prototype.registerEventHandlers = function () {
        var _this = this;
        this.emitter.on('cordova:pause', function () {
            _this.app.closed = true;
        });
        this.emitter.on('cordova:resume', function () {
            _this.app.closed = false;
        });
    };
    return Cordova;
}());
exports.Cordova = Cordova;

},{}],5:[function(require,module,exports){
"use strict";
/**
 * @hidden
 */
var Core = (function () {
    function Core(deps) {
        /**
         * @private
         */
        this._version = '0.8.0';
        this.config = deps.config;
        this.logger = deps.logger;
        this.emitter = deps.emitter;
        this.insights = deps.insights;
    }
    Core.prototype.init = function () {
        this.registerEventHandlers();
        this.onResume();
    };
    Object.defineProperty(Core.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    Core.prototype.onResume = function () {
        this.insights.track('mobileapp.opened');
    };
    /**
     * @private
     */
    Core.prototype.registerEventHandlers = function () {
        var _this = this;
        this.emitter.on('cordova:resume', function () {
            _this.onResume();
        });
        this.emitter.on('push:notification', function (data) {
            if (data.message.app.asleep || data.message.app.closed) {
                _this.insights.track('mobileapp.opened.push');
            }
        });
    };
    return Core;
}());
exports.Core = Core;

},{}],6:[function(require,module,exports){
"use strict";
var promise_1 = require('../promise');
var NO_PLUGIN = new Error('Missing deploy plugin: `ionic-plugin-deploy`');
/**
 * `Deploy` handles live deploys of the app. Downloading, extracting, and
 * rolling back snapshots.
 *
 * @featured
 */
var Deploy = (function () {
    function Deploy(deps, 
        /**
         * @hidden
         */
        options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.options = options;
        /**
         * The active deploy channel. Set this to change the channel on which
         * `Deploy` operates.
         */
        this.channel = 'production';
        this.config = deps.config;
        this.emitter = deps.emitter;
        this.logger = deps.logger;
        this.emitter.once('device:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.init(_this.config.get('app_id'), _this.config.getURL('api'));
            }
            _this.emitter.emit('deploy:ready');
        });
    }
    /**
     * Check for updates on the active channel.
     *
     * The promise resolves with a boolean. When `true`, a new snapshot exists on
     * the channel.
     */
    Deploy.prototype.check = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.check(_this.config.get('app_id'), _this.channel, function (result) {
                    if (result && result === 'true') {
                        _this.logger.info('Ionic Deploy: an update is available');
                        deferred.resolve(true);
                    }
                    else {
                        _this.logger.info('Ionic Deploy: no updates available');
                        deferred.resolve(false);
                    }
                }, function (error) {
                    _this.logger.error('Ionic Deploy: encountered an error while checking for updates');
                    deferred.reject(error);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Download the available snapshot.
     *
     * This should be used in conjunction with
     * [`extract()`](/api/client/deploy/#extract).
     *
     * @param options
     *  Options for this download, such as a progress callback.
     */
    Deploy.prototype.download = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var deferred = new promise_1.DeferredPromise();
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.download(_this.config.get('app_id'), function (result) {
                    if (result !== 'true' && result !== 'false') {
                        if (options.onProgress) {
                            options.onProgress(result);
                        }
                    }
                    else {
                        if (result === 'true') {
                            _this.logger.info('Ionic Deploy: download complete');
                        }
                        deferred.resolve(result === 'true');
                    }
                }, function (error) {
                    deferred.reject(error);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Extract the downloaded snapshot.
     *
     * This should be called after [`download()`](/api/client/deploy/#download)
     * successfully resolves.
     *
     * @param options
     */
    Deploy.prototype.extract = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var deferred = new promise_1.DeferredPromise();
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.extract(_this.config.get('app_id'), function (result) {
                    if (result !== 'done') {
                        if (options.onProgress) {
                            options.onProgress(result);
                        }
                    }
                    else {
                        if (result === 'true') {
                            _this.logger.info('Ionic Deploy: extraction complete');
                        }
                        deferred.resolve(result === 'true');
                    }
                }, function (error) {
                    deferred.reject(error);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Immediately reload the app with the latest deployed snapshot.
     *
     * This is only necessary to call if you have downloaded and extracted a
     * snapshot and wish to instantly reload the app with the latest deploy. The
     * latest deploy will automatically be loaded when the app is started.
     */
    Deploy.prototype.load = function () {
        var _this = this;
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.redirect(_this.config.get('app_id'));
            }
        });
    };
    /**
     * Get information about the current snapshot.
     *
     * The promise is resolved with an object that has key/value pairs pertaining
     * to the currently deployed snapshot.
     */
    Deploy.prototype.info = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise(); // TODO
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.info(_this.config.get('app_id'), function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * List the snapshots that have been installed on this device.
     *
     * The promise is resolved with an array of snapshot UUIDs.
     */
    Deploy.prototype.getSnapshots = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise(); // TODO
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.getVersions(_this.config.get('app_id'), function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Remove a snapshot from this device.
     *
     * @param uuid
     *  The snapshot UUID to remove from the device.
     */
    Deploy.prototype.deleteSnapshot = function (uuid) {
        var _this = this;
        var deferred = new promise_1.DeferredPromise(); // TODO
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.deleteVersion(_this.config.get('app_id'), uuid, function (result) {
                    deferred.resolve(result);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * Fetches the metadata for a given snapshot. If no UUID is given, it will
     * attempt to grab the metadata for the most recently known snapshot.
     *
     * @param uuid
     *  The snapshot from which to grab metadata.
     */
    Deploy.prototype.getMetadata = function (uuid) {
        var _this = this;
        var deferred = new promise_1.DeferredPromise(); // TODO
        this.emitter.once('deploy:ready', function () {
            if (_this._getPlugin()) {
                _this.plugin.getMetadata(_this.config.get('app_id'), uuid, function (result) {
                    deferred.resolve(result.metadata);
                }, function (err) {
                    deferred.reject(err);
                });
            }
            else {
                deferred.reject(NO_PLUGIN);
            }
        });
        return deferred.promise;
    };
    /**
     * @private
     */
    Deploy.prototype._getPlugin = function () {
        if (typeof window.IonicDeploy === 'undefined') {
            this.logger.warn('Ionic Deploy: Disabled! Deploy plugin is not installed or has not loaded. Have you run `ionic plugin add ionic-plugin-deploy` yet?');
            return;
        }
        if (!this.plugin) {
            this.plugin = window.IonicDeploy;
        }
        return this.plugin;
    };
    return Deploy;
}());
exports.Deploy = Deploy;

},{"../promise":14}],7:[function(require,module,exports){
"use strict";
/**
 * @hidden
 */
var Device = (function () {
    function Device(deps) {
        this.deps = deps;
        this.emitter = this.deps.emitter;
        this.deviceType = this.determineDeviceType();
        this.registerEventHandlers();
    }
    Device.prototype.isAndroid = function () {
        return this.deviceType === 'android';
    };
    Device.prototype.isIOS = function () {
        return this.deviceType === 'iphone' || this.deviceType === 'ipad';
    };
    Device.prototype.isConnectedToNetwork = function (options) {
        if (options === void 0) { options = {}; }
        if (typeof navigator.connection === 'undefined' ||
            typeof navigator.connection.type === 'undefined' ||
            typeof Connection === 'undefined') {
            if (!options.strictMode) {
                return true;
            }
            return false;
        }
        switch (navigator.connection.type) {
            case Connection.ETHERNET:
            case Connection.WIFI:
            case Connection.CELL_2G:
            case Connection.CELL_3G:
            case Connection.CELL_4G:
            case Connection.CELL:
                return true;
            default:
                return false;
        }
    };
    /**
     * @private
     */
    Device.prototype.registerEventHandlers = function () {
        var _this = this;
        if (this.deviceType === 'unknown') {
            this.emitter.emit('device:ready');
        }
        else {
            this.emitter.once('cordova:deviceready', function () {
                _this.emitter.emit('device:ready');
            });
        }
    };
    /**
     * @private
     */
    Device.prototype.determineDeviceType = function () {
        var agent = navigator.userAgent;
        var ipad = agent.match(/iPad/i);
        if (ipad && (ipad[0].toLowerCase() === 'ipad')) {
            return 'ipad';
        }
        var iphone = agent.match(/iPhone/i);
        if (iphone && (iphone[0].toLowerCase() === 'iphone')) {
            return 'iphone';
        }
        var android = agent.match(/Android/i);
        if (android && (android[0].toLowerCase() === 'android')) {
            return 'android';
        }
        return 'unknown';
    };
    return Device;
}());
exports.Device = Device;

},{}],8:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var auth_1 = require('./auth');
var client_1 = require('./client');
var config_1 = require('./config');
var cordova_1 = require('./cordova');
var core_1 = require('./core');
var deploy_1 = require('./deploy/deploy');
var device_1 = require('./device');
var events_1 = require('./events');
var insights_1 = require('./insights');
var logger_1 = require('./logger');
var push_1 = require('./push/push');
var storage_1 = require('./storage');
var user_1 = require('./user/user');
var modules = {};
function cache(target, propertyKey, descriptor) {
    var method = descriptor.get;
    descriptor.get = function () {
        if (typeof modules[propertyKey] === 'undefined') {
            var value = method.apply(this, arguments);
            modules[propertyKey] = value;
        }
        return modules[propertyKey];
    };
    descriptor.set = function (value) { };
}
/**
 * @hidden
 */
var Container = (function () {
    function Container() {
    }
    Object.defineProperty(Container.prototype, "appStatus", {
        get: function () {
            return { 'asleep': false, 'closed': false };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "config", {
        get: function () {
            return new config_1.Config();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "eventEmitter", {
        get: function () {
            return new events_1.EventEmitter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "logger", {
        get: function () {
            return new logger_1.Logger(this.config.settings.logger);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "localStorageStrategy", {
        get: function () {
            return new storage_1.LocalStorageStrategy();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "sessionStorageStrategy", {
        get: function () {
            return new storage_1.SessionStorageStrategy();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "authTokenContext", {
        get: function () {
            var label = 'auth_' + this.config.get('app_id');
            return new auth_1.CombinedAuthTokenContext({
                'storage': new storage_1.Storage({ 'strategy': this.localStorageStrategy }),
                'tempStorage': new storage_1.Storage({ 'strategy': this.sessionStorageStrategy })
            }, label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "client", {
        get: function () {
            return new client_1.Client(this.authTokenContext, this.config.getURL('api'));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "insights", {
        get: function () {
            return new insights_1.Insights({
                'appStatus': this.appStatus,
                'storage': new storage_1.Storage({ 'strategy': this.localStorageStrategy }),
                'config': this.config,
                'client': this.client,
                'logger': this.logger
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "core", {
        get: function () {
            return new core_1.Core({
                'config': this.config,
                'logger': this.logger,
                'emitter': this.eventEmitter,
                'insights': this.insights
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "device", {
        get: function () {
            return new device_1.Device({ 'emitter': this.eventEmitter });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "cordova", {
        get: function () {
            return new cordova_1.Cordova({
                'appStatus': this.appStatus,
                'device': this.device,
                'emitter': this.eventEmitter,
                'logger': this.logger
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "userContext", {
        get: function () {
            return new user_1.UserContext({ 'storage': new storage_1.Storage({ 'strategy': this.localStorageStrategy }), 'config': this.config });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "singleUserService", {
        get: function () {
            return new user_1.SingleUserService({ 'client': this.client, 'context': this.userContext });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "authModules", {
        get: function () {
            return {
                'basic': new auth_1.BasicAuth({ 'config': this.config, 'client': this.client }),
                'custom': new auth_1.CustomAuth({ 'config': this.config, 'client': this.client }),
                'twitter': new auth_1.TwitterAuth({ 'config': this.config, 'client': this.client }),
                'facebook': new auth_1.FacebookAuth({ 'config': this.config, 'client': this.client }),
                'github': new auth_1.GithubAuth({ 'config': this.config, 'client': this.client }),
                'google': new auth_1.GoogleAuth({ 'config': this.config, 'client': this.client }),
                'instagram': new auth_1.InstagramAuth({ 'config': this.config, 'client': this.client }),
                'linkedin': new auth_1.LinkedInAuth({ 'config': this.config, 'client': this.client })
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "auth", {
        get: function () {
            return new auth_1.Auth({
                'config': this.config,
                'emitter': this.eventEmitter,
                'authModules': this.authModules,
                'tokenContext': this.authTokenContext,
                'userService': this.singleUserService,
                'storage': new storage_1.Storage({ 'strategy': this.localStorageStrategy })
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "push", {
        get: function () {
            var config = this.config;
            return new push_1.Push({
                'config': config,
                'auth': this.auth,
                'userService': this.singleUserService,
                'device': this.device,
                'client': this.client,
                'emitter': this.eventEmitter,
                'storage': new storage_1.Storage({ 'strategy': this.localStorageStrategy }),
                'logger': this.logger
            }, config.settings.push);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "deploy", {
        get: function () {
            return new deploy_1.Deploy({
                'config': this.config,
                'emitter': this.eventEmitter,
                'logger': this.logger
            });
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "appStatus", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "config", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "eventEmitter", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "logger", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "localStorageStrategy", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "sessionStorageStrategy", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "authTokenContext", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "client", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "insights", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "core", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "device", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "cordova", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "userContext", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "singleUserService", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "authModules", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "auth", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "push", null);
    __decorate([
        cache, 
        __metadata('design:type', Object)
    ], Container.prototype, "deploy", null);
    return Container;
}());
exports.Container = Container;

},{"./auth":1,"./client":2,"./config":3,"./cordova":4,"./core":5,"./deploy/deploy":6,"./device":7,"./events":10,"./insights":12,"./logger":13,"./push/push":16,"./storage":17,"./user/user":19}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @hidden
 */
var Exception = (function (_super) {
    __extends(Exception, _super);
    function Exception(message) {
        _super.call(this, message);
        this.message = message;
        this.name = 'Exception';
        this.stack = (new Error()).stack;
    }
    Exception.prototype.toString = function () {
        return this.name + ": " + this.message;
    };
    return Exception;
}(Error));
exports.Exception = Exception;
/**
 * An error with generic error details.
 *
 * Error details can be extracted depending on the type of `D`. For instance,
 * if the type of `D` is `string[]`, you can do this:
 *
 * ```typescript
 * function handleError(err: IDetailedError<string[]>) {
 *   for (let i in err.details) {
 *     console.error('got error code: ' + i);
 *   }
 * }
 * ```
 *
 * @featured
 */
var DetailedError = (function (_super) {
    __extends(DetailedError, _super);
    function DetailedError(
        /**
         * The error message.
         */
        message, 
        /**
         * The error details.
         */
        details) {
        _super.call(this, message);
        this.message = message;
        this.details = details;
        this.name = 'DetailedError';
    }
    return DetailedError;
}(Exception));
exports.DetailedError = DetailedError;

},{}],10:[function(require,module,exports){
"use strict";
/**
 * A registered event receiver.
 */
var EventReceiver = (function () {
    function EventReceiver(
        /**
         * An registered identifier for this event receiver.
         */
        key, 
        /**
         * The registered name of the event.
         */
        event, 
        /**
         * The actual callback.
         */
        handler) {
        this.key = key;
        this.event = event;
        this.handler = handler;
    }
    return EventReceiver;
}());
exports.EventReceiver = EventReceiver;
/**
 * Stores callbacks for registered events.
 */
var EventEmitter = (function () {
    function EventEmitter() {
        /**
         * @private
         */
        this.n = 0;
        /**
         * @private
         */
        this.eventReceivers = {};
        /**
         * @private
         */
        this.eventsEmitted = {};
    }
    /**
     * Register an event callback which gets triggered every time the event is
     * fired.
     *
     * @param event
     *  The event name.
     * @param callback
     *  A callback to attach to this event.
     */
    EventEmitter.prototype.on = function (event, callback) {
        if (typeof this.eventReceivers[event] === 'undefined') {
            this.eventReceivers[event] = {};
        }
        var receiver = new EventReceiver(this.n, event, callback);
        this.n++;
        this.eventReceivers[event][receiver.key] = receiver;
        return receiver;
    };
    /**
     * Unregister an event receiver returned from
     * [`on()`](/api/client/eventemitter#on).
     *
     * @param receiver
     *  The event receiver.
     */
    EventEmitter.prototype.off = function (receiver) {
        if (typeof this.eventReceivers[receiver.event] === 'undefined' ||
            typeof this.eventReceivers[receiver.event][receiver.key] === 'undefined') {
            throw new Error('unknown event receiver');
        }
        delete this.eventReceivers[receiver.event][receiver.key];
    };
    /**
     * Register an event callback that gets triggered only once. If the event was
     * triggered before your callback is registered, it calls your callback
     * immediately.
     *
     * @note TODO: Fix the docs for () => void syntax.
     *
     * @param event
     *  The event name.
     * @param callback
     *  A callback to attach to this event. It takes no arguments.
     */
    EventEmitter.prototype.once = function (event, callback) {
        var _this = this;
        if (this.emitted(event)) {
            callback();
        }
        else {
            this.on(event, function () {
                if (!_this.emitted(event)) {
                    callback();
                }
            });
        }
    };
    /**
     * Trigger an event. Call all callbacks in the order they were registered.
     *
     * @param event
     *  The event name.
     * @param data
     *  An object to pass to every callback.
     */
    EventEmitter.prototype.emit = function (event, data) {
        if (data === void 0) { data = null; }
        if (typeof this.eventReceivers[event] === 'undefined') {
            this.eventReceivers[event] = {};
        }
        if (typeof this.eventsEmitted[event] === 'undefined') {
            this.eventsEmitted[event] = 0;
        }
        for (var k in this.eventReceivers[event]) {
            this.eventReceivers[event][k].handler(data);
        }
        this.eventsEmitted[event] += 1;
    };
    /**
     * Return a count of the number of times an event has been triggered.
     *
     * @param event
     *  The event name.
     */
    EventEmitter.prototype.emitted = function (event) {
        if (typeof this.eventsEmitted[event] === 'undefined') {
            return 0;
        }
        return this.eventsEmitted[event];
    };
    return EventEmitter;
}());
exports.EventEmitter = EventEmitter;

},{}],11:[function(require,module,exports){
"use strict";
var auth_1 = require('./auth');
exports.Auth = auth_1.Auth;
exports.AuthType = auth_1.AuthType;
exports.BasicAuth = auth_1.BasicAuth;
exports.CustomAuth = auth_1.CustomAuth;
exports.FacebookAuth = auth_1.FacebookAuth;
exports.GithubAuth = auth_1.GithubAuth;
exports.GoogleAuth = auth_1.GoogleAuth;
exports.InstagramAuth = auth_1.InstagramAuth;
exports.LinkedInAuth = auth_1.LinkedInAuth;
exports.TwitterAuth = auth_1.TwitterAuth;
var client_1 = require('./client');
exports.Client = client_1.Client;
var config_1 = require('./config');
exports.Config = config_1.Config;
var cordova_1 = require('./cordova');
exports.Cordova = cordova_1.Cordova;
var core_1 = require('./core');
exports.Core = core_1.Core;
var deploy_1 = require('./deploy/deploy');
exports.Deploy = deploy_1.Deploy;
var device_1 = require('./device');
exports.Device = device_1.Device;
var errors_1 = require('./errors');
exports.Exception = errors_1.Exception;
exports.DetailedError = errors_1.DetailedError;
var di_1 = require('./di');
exports.DIContainer = di_1.Container;
var events_1 = require('./events');
exports.EventEmitter = events_1.EventEmitter;
var insights_1 = require('./insights');
exports.Insights = insights_1.Insights;
var logger_1 = require('./logger');
exports.Logger = logger_1.Logger;
var push_1 = require('./push/push');
exports.Push = push_1.Push;
var message_1 = require('./push/message');
exports.PushMessage = message_1.PushMessage;
var storage_1 = require('./storage');
exports.Storage = storage_1.Storage;
exports.LocalStorageStrategy = storage_1.LocalStorageStrategy;
exports.SessionStorageStrategy = storage_1.SessionStorageStrategy;
var user_1 = require('./user/user');
exports.UserContext = user_1.UserContext;
exports.User = user_1.User;
exports.SingleUserService = user_1.SingleUserService;

},{"./auth":1,"./client":2,"./config":3,"./cordova":4,"./core":5,"./deploy/deploy":6,"./device":7,"./di":8,"./errors":9,"./events":10,"./insights":12,"./logger":13,"./push/message":15,"./push/push":16,"./storage":17,"./user/user":19}],12:[function(require,module,exports){
"use strict";
/**
 * @hidden
 */
var Stat = (function () {
    function Stat(appId, stat, value) {
        if (value === void 0) { value = 1; }
        this.appId = appId;
        this.stat = stat;
        this.value = value;
        this.appId = appId;
        this.stat = stat;
        this.value = value;
        this.created = new Date();
    }
    Stat.prototype.toJSON = function () {
        return {
            app_id: this.appId,
            stat: this.stat,
            value: this.value,
            created: this.created.toISOString(),
        };
    };
    return Stat;
}());
exports.Stat = Stat;
/**
 * A client for Insights that handles batching, user activity insight, and
 * sending insights at an interval.
 *
 * @hidden
 */
var Insights = (function () {
    function Insights(deps, options) {
        var _this = this;
        if (options === void 0) { options = {
            'intervalSubmit': 60 * 1000,
            'intervalActiveCheck': 1000,
            'submitCount': 100
        }; }
        this.options = options;
        this.app = deps.appStatus;
        this.storage = deps.storage;
        this.config = deps.config;
        this.client = deps.client;
        this.logger = deps.logger;
        this.batch = [];
        setInterval(function () {
            _this.submit();
        }, this.options.intervalSubmit);
        setInterval(function () {
            if (!_this.app.closed) {
                _this.checkActivity();
            }
        }, this.options.intervalActiveCheck);
    }
    /**
     * Track an insight.
     *
     * @param stat - The insight name.
     * @param value - The number by which to increment this insight.
     */
    Insights.prototype.track = function (stat, value) {
        if (value === void 0) { value = 1; }
        this.trackStat(new Stat(this.config.get('app_id'), stat, value));
    };
    Insights.prototype.checkActivity = function () {
        var session = this.storage.get('insights_session');
        if (!session) {
            this.markActive();
        }
        else {
            var d = new Date(session);
            var hour = 60 * 60 * 1000;
            if (d.getTime() + hour < new Date().getTime()) {
                this.markActive();
            }
        }
    };
    Insights.prototype.markActive = function () {
        this.storage.set('insights_session', new Date().toISOString());
        this.track('mobileapp.active');
    };
    Insights.prototype.trackStat = function (stat) {
        this.batch.push(stat);
        if (this.shouldSubmit()) {
            this.submit();
        }
    };
    Insights.prototype.shouldSubmit = function () {
        return this.batch.length >= this.options.submitCount;
    };
    Insights.prototype.submit = function () {
        var _this = this;
        if (this.batch.length === 0) {
            return;
        }
        var insights = [];
        for (var _i = 0, _a = this.batch; _i < _a.length; _i++) {
            var stat = _a[_i];
            insights.push(stat.toJSON());
        }
        this.client.post('/insights')
            .send({ 'insights': insights })
            .end(function (err, res) {
            if (err) {
                _this.logger.error('Ionic Insights: Could not send insights.', err);
            }
        });
        this.batch = [];
    };
    return Insights;
}());
exports.Insights = Insights;

},{}],13:[function(require,module,exports){
"use strict";
/**
 * Simple console logger.
 */
var Logger = (function () {
    function Logger(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        /**
         * The function to use to log info level messages.
         */
        this.infofn = console.log.bind(console);
        /**
         * The function to use to log warn level messages.
         */
        this.warnfn = console.warn.bind(console);
        /**
         * The function to use to log error level messages.
         */
        this.errorfn = console.error.bind(console);
    }
    /**
     * Send a log at info level.
     *
     * @note TODO: Fix optionalParams in docs.
     *
     * @param message - The message to log.
     */
    Logger.prototype.info = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (!this.options.silent) {
            this.infofn.apply(this, [message].concat(optionalParams));
        }
    };
    /**
     * Send a log at warn level.
     *
     * @note TODO: Fix optionalParams in docs.
     *
     * @param message - The message to log.
     */
    Logger.prototype.warn = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (!this.options.silent) {
            this.warnfn.apply(this, [message].concat(optionalParams));
        }
    };
    /**
     * Send a log at error level.
     *
     * @note TODO: Fix optionalParams in docs.
     *
     * @param message - The message to log.
     */
    Logger.prototype.error = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        this.errorfn.apply(this, [message].concat(optionalParams));
    };
    return Logger;
}());
exports.Logger = Logger;

},{}],14:[function(require,module,exports){
"use strict";
/**
 * @hidden
 */
var DeferredPromise = (function () {
    function DeferredPromise() {
        this.init();
    }
    DeferredPromise.prototype.init = function () {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    };
    return DeferredPromise;
}());
exports.DeferredPromise = DeferredPromise;

},{}],15:[function(require,module,exports){
"use strict";
/**
 * Represents a push notification sent to the device.
 *
 * @featured
 */
var PushMessage = (function () {
    function PushMessage() {
    }
    /**
     * Create a PushMessage from the push plugin's format.
     *
     * @hidden
     *
     * @param data - The plugin's notification object.
     */
    PushMessage.fromPluginData = function (data) {
        var message = new PushMessage();
        message.raw = data;
        message.text = data.message;
        message.title = data.title;
        message.count = data.count;
        message.sound = data.sound;
        message.image = data.image;
        message.app = {
            'asleep': !data.additionalData.foreground,
            'closed': data.additionalData.coldstart
        };
        message.payload = data.additionalData['payload'];
        return message;
    };
    PushMessage.prototype.toString = function () {
        return "<PushMessage [\"" + this.title + "\"]>";
    };
    return PushMessage;
}());
exports.PushMessage = PushMessage;

},{}],16:[function(require,module,exports){
"use strict";
var promise_1 = require('../promise');
var message_1 = require('./message');
/**
 * `Push` handles push notifications for this app.
 *
 * @featured
 */
var Push = (function () {
    function Push(deps, options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        /**
         * @private
         */
        this.blockRegistration = false;
        /**
         * @private
         */
        this.blockUnregister = false;
        /**
         * @private
         */
        this.blockSaveToken = false;
        /**
         * @private
         */
        this.registered = false;
        this.config = deps.config;
        this.auth = deps.auth;
        this.userService = deps.userService;
        this.device = deps.device;
        this.client = deps.client;
        this.emitter = deps.emitter;
        this.storage = deps.storage;
        this.logger = deps.logger;
        // Check for the required values to use this service
        if (this.device.isAndroid() && !this.options.sender_id) {
            this.logger.error('Ionic Push: GCM project number not found (http://docs.ionic.io/docs/push-android-setup)');
            return;
        }
        if (!options.pluginConfig) {
            options.pluginConfig = {};
        }
        if (this.device.isAndroid()) {
            // inject gcm key for PushPlugin
            if (!options.pluginConfig.android) {
                options.pluginConfig.android = {};
            }
            if (!options.pluginConfig.android.senderID) {
                options.pluginConfig.android.senderID = this.options.sender_id;
            }
        }
        this.options = options;
    }
    Object.defineProperty(Push.prototype, "token", {
        get: function () {
            if (!this._token) {
                this._token = this.storage.get('push_token');
            }
            return this._token;
        },
        set: function (val) {
            if (!val) {
                this.storage.delete('push_token');
            }
            else {
                this.storage.set('push_token', val);
            }
            this._token = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Register a token with the API.
     *
     * When a token is saved, you can send push notifications to it. If a user is
     * logged in, the token is linked to them by their ID.
     *
     * @param token - The token.
     * @param options
     */
    Push.prototype.saveToken = function (token, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var deferred = new promise_1.DeferredPromise();
        var tokenData = {
            'token': token.token,
            'app_id': this.config.get('app_id')
        };
        if (!options.ignore_user) {
            var user = this.userService.current();
            if (this.auth.isAuthenticated()) {
                tokenData.user_id = user.id;
            }
        }
        if (!this.blockSaveToken) {
            this.client.post('/push/tokens')
                .send(tokenData)
                .end(function (err, res) {
                if (err) {
                    _this.blockSaveToken = false;
                    _this.logger.error('Ionic Push:', err);
                    deferred.reject(err);
                }
                else {
                    _this.blockSaveToken = false;
                    _this.logger.info('Ionic Push: saved push token: ' + token);
                    if (tokenData.user_id) {
                        _this.logger.info('Ionic Push: added push token to user: ' + tokenData.user_id);
                    }
                    token.id = res.body.data.id;
                    token.type = res.body.data.type;
                    token.saved = true;
                    deferred.resolve(token);
                }
            });
        }
        else {
            deferred.reject(new Error('A token save operation is already in progress.'));
        }
        return deferred.promise;
    };
    /**
     * Registers the device with GCM/APNS to get a push token.
     *
     * After a device is registered, you will likely want to save the token with
     * [`saveToken()`](/api/client/push/#saveToken) to the API.
     */
    Push.prototype.register = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        if (this.blockRegistration) {
            deferred.reject(new Error('Another registration is already in progress.'));
        }
        else {
            this.blockRegistration = true;
            this.emitter.once('device:ready', function () {
                var pushPlugin = _this._getPushPlugin();
                if (pushPlugin) {
                    _this.plugin = pushPlugin.init(_this.options.pluginConfig);
                    _this.plugin.on('registration', function (data) {
                        _this.blockRegistration = false;
                        _this.token = { 'token': data.registrationId };
                        _this.token.registered = true;
                        deferred.resolve(_this.token);
                    });
                    _this._callbackRegistration();
                    _this.registered = true;
                }
                else {
                    deferred.reject(new Error('Push plugin not found! See logs.'));
                }
            });
        }
        return deferred.promise;
    };
    /**
     * Invalidate the current push token.
     */
    Push.prototype.unregister = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        if (!this.blockUnregister) {
            var pushToken_1 = this.token;
            if (!pushToken_1) {
                deferred.resolve();
            }
            else {
                var tokenData = {
                    'token': pushToken_1.token,
                    'app_id': this.config.get('app_id')
                };
                if (this.plugin) {
                    this.plugin.unregister(function () { }, function () { });
                }
                this.client.post('/push/tokens/invalidate')
                    .send(tokenData)
                    .end(function (err, res) {
                    _this.blockUnregister = false;
                    if (err) {
                        _this.logger.error('Ionic Push:', err);
                        deferred.reject(err);
                    }
                    else {
                        _this.logger.info('Ionic Push: unregistered push token: ' + pushToken_1.token);
                        _this.token = null;
                        deferred.resolve();
                    }
                });
            }
        }
        else {
            deferred.reject(new Error('An unregister operation is already in progress.'));
        }
        this.blockUnregister = true;
        return deferred.promise;
    };
    /**
     * @private
     */
    Push.prototype._callbackRegistration = function () {
        var _this = this;
        this.plugin.on('registration', function (data) {
            _this.token = { 'token': data.registrationId };
            if (_this.options.debug) {
                _this.logger.info('Ionic Push (debug): device token registered: ' + _this.token);
            }
            _this.emitter.emit('push:register', _this.token);
        });
        this.plugin.on('notification', function (data) {
            var message = message_1.PushMessage.fromPluginData(data);
            if (_this.options.debug) {
                _this.logger.info('Ionic Push (debug): notification received: ' + message);
            }
            _this.emitter.emit('push:notification', { 'message': message, 'raw': data });
        });
        this.plugin.on('error', function (e) {
            if (_this.options.debug) {
                _this.logger.error('Ionic Push (debug): unexpected error occured.');
                _this.logger.error('Ionic Push:', e);
            }
            _this.emitter.emit('push:error', { 'err': e });
        });
    };
    /**
     * @private
     */
    Push.prototype._getPushPlugin = function () {
        var plugin = window.PushNotification;
        if (!plugin) {
            if (this.device.isIOS() || this.device.isAndroid()) {
                this.logger.error('Ionic Push: PushNotification plugin is required. Have you run `ionic plugin add phonegap-plugin-push` ?');
            }
            else {
                this.logger.warn('Ionic Push: Disabled! Native push notifications will not work in a browser. Run your app on an actual device to use push.');
            }
        }
        return plugin;
    };
    return Push;
}());
exports.Push = Push;

},{"../promise":14,"./message":15}],17:[function(require,module,exports){
"use strict";
/**
 * @hidden
 */
var LocalStorageStrategy = (function () {
    function LocalStorageStrategy() {
    }
    LocalStorageStrategy.prototype.get = function (key) {
        return localStorage.getItem(key);
    };
    LocalStorageStrategy.prototype.set = function (key, value) {
        return localStorage.setItem(key, value);
    };
    LocalStorageStrategy.prototype.delete = function (key) {
        return localStorage.removeItem(key);
    };
    return LocalStorageStrategy;
}());
exports.LocalStorageStrategy = LocalStorageStrategy;
/**
 * @hidden
 */
var SessionStorageStrategy = (function () {
    function SessionStorageStrategy() {
    }
    SessionStorageStrategy.prototype.get = function (key) {
        return sessionStorage.getItem(key);
    };
    SessionStorageStrategy.prototype.set = function (key, value) {
        return sessionStorage.setItem(key, value);
    };
    SessionStorageStrategy.prototype.delete = function (key) {
        return sessionStorage.removeItem(key);
    };
    return SessionStorageStrategy;
}());
exports.SessionStorageStrategy = SessionStorageStrategy;
/**
 * A generic local/session storage abstraction.
 */
var Storage = (function () {
    function Storage(deps, options) {
        if (options === void 0) { options = { 'prefix': 'ionic', 'cache': true }; }
        this.options = options;
        this.strategy = deps.strategy;
        this.storageCache = {};
    }
    /**
     * Set a value in the storage by the given key.
     *
     * @param key - The storage key to set.
     * @param value - The value to set. (Must be JSON-serializable).
     */
    Storage.prototype.set = function (key, value) {
        key = this.standardizeKey(key);
        var json = JSON.stringify(value);
        this.strategy.set(key, json);
        if (this.options.cache) {
            this.storageCache[key] = value;
        }
    };
    /**
     * Delete a value from the storage by the given key.
     *
     * @param key - The storage key to delete.
     */
    Storage.prototype.delete = function (key) {
        key = this.standardizeKey(key);
        this.strategy.delete(key);
        if (this.options.cache) {
            delete this.storageCache[key];
        }
    };
    /**
     * Get a value from the storage by the given key.
     *
     * @param key - The storage key to get.
     */
    Storage.prototype.get = function (key) {
        key = this.standardizeKey(key);
        if (this.options.cache) {
            var cached = this.storageCache[key];
            if (cached) {
                return cached;
            }
        }
        var json = this.strategy.get(key);
        if (!json) {
            return null;
        }
        try {
            var value = JSON.parse(json);
            if (this.options.cache) {
                this.storageCache[key] = value;
            }
            return value;
        }
        catch (err) {
            return null;
        }
    };
    /**
     * @private
     */
    Storage.prototype.standardizeKey = function (key) {
        return this.options.prefix + "_" + key;
    };
    return Storage;
}());
exports.Storage = Storage;

},{}],18:[function(require,module,exports){
"use strict";
var dataTypeMapping = {};
var DataTypeSchema = (function () {
    function DataTypeSchema(properties) {
        this.data = {};
        this.setProperties(properties);
    }
    DataTypeSchema.prototype.setProperties = function (properties) {
        if (properties instanceof Object) {
            for (var x in properties) {
                this.data[x] = properties[x];
            }
        }
    };
    DataTypeSchema.prototype.toJSON = function () {
        var data = this.data;
        return {
            '__Ionic_DataTypeSchema': data.name,
            'value': data.value
        };
    };
    DataTypeSchema.prototype.isValid = function () {
        if (this.data.name && this.data.value) {
            return true;
        }
        return false;
    };
    return DataTypeSchema;
}());
exports.DataTypeSchema = DataTypeSchema;
var DataType = (function () {
    function DataType() {
    }
    DataType.get = function (name, value) {
        if (dataTypeMapping[name]) {
            return new dataTypeMapping[name](value);
        }
        return false;
    };
    DataType.getMapping = function () {
        return dataTypeMapping;
    };
    Object.defineProperty(DataType, "Schema", {
        get: function () {
            return DataTypeSchema;
        },
        enumerable: true,
        configurable: true
    });
    DataType.register = function (name, cls) {
        dataTypeMapping[name] = cls;
    };
    return DataType;
}());
exports.DataType = DataType;
var UniqueArray = (function () {
    function UniqueArray(value) {
        this.data = [];
        if (value instanceof Array) {
            for (var x in value) {
                this.push(value[x]);
            }
        }
    }
    UniqueArray.prototype.toJSON = function () {
        var data = this.data;
        var schema = new DataTypeSchema({ 'name': 'UniqueArray', 'value': data });
        return schema.toJSON();
    };
    UniqueArray.fromStorage = function (value) {
        return new UniqueArray(value);
    };
    UniqueArray.prototype.push = function (value) {
        if (this.data.indexOf(value) === -1) {
            this.data.push(value);
        }
    };
    UniqueArray.prototype.pull = function (value) {
        var index = this.data.indexOf(value);
        this.data.splice(index, 1);
    };
    return UniqueArray;
}());
exports.UniqueArray = UniqueArray;
DataType.register('UniqueArray', UniqueArray);

},{}],19:[function(require,module,exports){
"use strict";
var promise_1 = require('../promise');
var data_types_1 = require('./data-types');
/**
 * @hidden
 */
var UserContext = (function () {
    function UserContext(deps) {
        this.config = deps.config;
        this.storage = deps.storage;
    }
    Object.defineProperty(UserContext.prototype, "label", {
        get: function () {
            return 'user_' + this.config.get('app_id');
        },
        enumerable: true,
        configurable: true
    });
    UserContext.prototype.unstore = function () {
        this.storage.delete(this.label);
    };
    UserContext.prototype.store = function (user) {
        this.storage.set(this.label, user.serializeForStorage());
    };
    UserContext.prototype.load = function (user) {
        var data = this.storage.get(this.label);
        if (data) {
            user.id = data.id;
            user.data = new UserData(data.data);
            user.details = data.details || {};
            user.social = data.social || {};
            user.fresh = data.fresh;
            return user;
        }
        return;
    };
    return UserContext;
}());
exports.UserContext = UserContext;
/**
 * @hidden
 */
var UserData = (function () {
    function UserData(data) {
        if (data === void 0) { data = {}; }
        this.data = {};
        if ((typeof data === 'object')) {
            this.data = data;
            this.deserializeDataTypes();
        }
    }
    UserData.prototype.get = function (key, defaultValue) {
        if (this.data.hasOwnProperty(key)) {
            return this.data[key];
        }
        else {
            if (defaultValue === 0 || defaultValue === false) {
                return defaultValue;
            }
            return defaultValue || null;
        }
    };
    UserData.prototype.set = function (key, value) {
        this.data[key] = value;
    };
    UserData.prototype.unset = function (key) {
        delete this.data[key];
    };
    /**
     * @private
     */
    UserData.prototype.deserializeDataTypes = function () {
        if (this.data) {
            for (var x in this.data) {
                // if we have an object, let's check for custom data types
                if (this.data[x] && typeof this.data[x] === 'object') {
                    // do we have a custom type?
                    if (this.data[x].__Ionic_DataTypeSchema) {
                        var name = this.data[x].__Ionic_DataTypeSchema;
                        var mapping = data_types_1.DataType.getMapping();
                        if (mapping[name]) {
                            // we have a custom type and a registered class, give the custom data type
                            // from storage
                            this.data[x] = mapping[name].fromStorage(this.data[x].value);
                        }
                    }
                }
            }
        }
    };
    return UserData;
}());
exports.UserData = UserData;
/**
 * Represents a user of the app.
 *
 * @featured
 */
var User = (function () {
    function User(deps) {
        /**
         * The details (email, password, etc) of this user.
         */
        this.details = {};
        /**
         * The social details of this user.
         */
        this.social = {};
        this.service = deps.service;
        this.fresh = true;
        this._unset = {};
        this.data = new UserData();
    }
    /**
     * Check whether this user is anonymous or not.
     *
     * If the `id` property is set, the user is no longer anonymous.
     */
    User.prototype.isAnonymous = function () {
        if (!this.id) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Get a value from this user's custom data.
     *
     * Optionally, a default value can be provided.
     *
     * @param key - The data key to get.
     * @param defaultValue - The value to return if the key is absent.
     */
    User.prototype.get = function (key, defaultValue) {
        return this.data.get(key, defaultValue);
    };
    /**
     * Set a value in this user's custom data.
     *
     * @param key - The data key to set.
     * @param value - The value to set.
     */
    User.prototype.set = function (key, value) {
        delete this._unset[key];
        return this.data.set(key, value);
    };
    /**
     * Delete a value from this user's custom data.
     *
     * @param key - The data key to delete.
     */
    User.prototype.unset = function (key) {
        this._unset[key] = true;
        return this.data.unset(key);
    };
    /**
     * Revert this user to a fresh, anonymous state.
     */
    User.prototype.clear = function () {
        this.id = null;
        this.data = new UserData();
        this.details = {};
        this.fresh = true;
    };
    /**
     * Save this user to the API.
     */
    User.prototype.save = function () {
        this._unset = {};
        return this.service.save();
    };
    /**
     * Delete this user from the API.
     */
    User.prototype.delete = function () {
        return this.service.delete();
    };
    /**
     * Load the user from the API, overwriting the local user's data.
     *
     * @param id - The user ID to load into this user.
     */
    User.prototype.load = function (id) {
        return this.service.load(id);
    };
    /**
     * Store this user in local storage.
     */
    User.prototype.store = function () {
        this.service.store();
    };
    /**
     * Remove this user from local storage.
     */
    User.prototype.unstore = function () {
        this.service.unstore();
    };
    /**
     * @hidden
     */
    User.prototype.serializeForAPI = function () {
        return {
            'email': this.details.email,
            'password': this.details.password,
            'username': this.details.username,
            'image': this.details.image,
            'name': this.details.name,
            'custom': this.data.data
        };
    };
    /**
     * @hidden
     */
    User.prototype.serializeForStorage = function () {
        return {
            'id': this.id,
            'data': this.data.data,
            'details': this.details,
            'fresh': this.fresh,
            'social': this.social
        };
    };
    User.prototype.toString = function () {
        return "<User [" + (this.isAnonymous() ? 'anonymous' : this.id) + "]>";
    };
    return User;
}());
exports.User = User;
/**
 * @hidden
 */
var SingleUserService = (function () {
    function SingleUserService(deps, config) {
        if (config === void 0) { config = {}; }
        this.config = config;
        this.client = deps.client;
        this.context = deps.context;
    }
    SingleUserService.prototype.current = function () {
        if (!this.user) {
            this.user = this.context.load(new User({ 'service': this }));
        }
        if (!this.user) {
            this.user = new User({ 'service': this });
        }
        return this.user;
    };
    SingleUserService.prototype.store = function () {
        this.context.store(this.current());
    };
    SingleUserService.prototype.unstore = function () {
        this.context.unstore();
    };
    SingleUserService.prototype.load = function (id) {
        if (id === void 0) { id = 'self'; }
        var deferred = new promise_1.DeferredPromise();
        var user = this.current();
        this.client.get("/users/" + id)
            .end(function (err, res) {
            if (err) {
                deferred.reject(err);
            }
            else {
                user.id = res.body.data.uuid;
                user.data = new UserData(res.body.data.custom);
                user.details = res.body.data.details;
                user.fresh = false;
                user.social = res.body.data.social;
                deferred.resolve();
            }
        });
        return deferred.promise;
    };
    SingleUserService.prototype.delete = function () {
        var deferred = new promise_1.DeferredPromise();
        if (this.user.isAnonymous()) {
            deferred.reject(new Error('User is anonymous and cannot be deleted from the API.'));
        }
        else {
            this.unstore();
            this.client.delete("/users/" + this.user.id)
                .end(function (err, res) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    deferred.resolve();
                }
            });
        }
        return deferred.promise;
    };
    SingleUserService.prototype.save = function () {
        var _this = this;
        var deferred = new promise_1.DeferredPromise();
        this.store();
        if (this.user.isAnonymous()) {
            deferred.reject(new Error('User is anonymous and cannot be updated in the API. Use load(<id>) or signup a user using auth.'));
        }
        else {
            this.client.patch("/users/" + this.user.id)
                .send(this.user.serializeForAPI())
                .end(function (err, res) {
                if (err) {
                    deferred.reject(err);
                }
                else {
                    _this.user.fresh = false;
                    deferred.resolve();
                }
            });
        }
        return deferred.promise;
    };
    return SingleUserService;
}());
exports.SingleUserService = SingleUserService;

},{"../promise":14,"./data-types":18}],20:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],21:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],22:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  root = this;
}

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pushEncodedKeyValuePair(pairs, key, obj[key]);
        }
      }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (Array.isArray(val)) {
    return val.forEach(function(v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  }
  pairs.push(encodeURIComponent(key)
    + '=' + encodeURIComponent(val));
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    if (err) {
      return self.callback(err, res);
    }

    if (res.status >= 200 && res.status < 300) {
      return self.callback(err, res);
    }

    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
    new_err.original = err;
    new_err.response = res;
    new_err.status = res.status;

    self.callback(new_err, res);
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr && this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and 
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || isHost(data)) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * @deprecated
 */
Response.prototype.parse = function serialize(fn){
  if (root.console) {
    console.warn("Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0");
  }
  this.serialize(fn);
  return this;
};

Response.prototype.serialize = function serialize(fn){
  this._parser = fn;
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self.timeoutError();
      if (self.aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":23,"./request":25,"./request-base":24,"emitter":20,"reduce":21}],23:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null != obj && 'object' == typeof obj;
}

module.exports = isObject;

},{}],24:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Force given parser
 *
 * Sets the body parser no matter type.
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Faux promise support
 *
 * @param {Function} fulfill
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(fulfill, reject) {
  return this.end(function(err, res) {
    err ? reject(err) : fulfill(res);
  });
}

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {
  this._getFormData().append(name, val);
  return this;
};

},{"./is-object":23}],25:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],26:[function(require,module,exports){
// Angular 1 modules and factories for the bundle

if (typeof angular === 'object' && angular.module) {

  angular.element(document).ready(function() {
    Ionic.core.init();
    Ionic.cordova.bootstrap();
  });

  angular.module('ionic.cloud', [])

  .provider('$ionicCloudConfig', function() {
    var config = Ionic.config;

    this.register = function(settings) {
      config.register(settings);
    };

    this.$get = function() {
      return config;
    };
  })

  .provider('$ionicCloud', ['$ionicCloudConfigProvider', function($ionicCloudConfigProvider) {
    this.init = function(value) {
      $ionicCloudConfigProvider.register(value);
    };

    this.$get = [function() {
      return Ionic.core;
    }];
  }])

  .factory('$ionicEventEmitter', ['$rootScope', function($rootScope) {
    var emit = Ionic.Cloud.EventEmitter.prototype.emit;

    Ionic.Cloud.EventEmitter.prototype.emit = function(name, data) {
      $rootScope.$broadcast('cloud:' + name, data);
      return emit.apply(this, arguments);
    };

    return Ionic.eventEmitter;
  }])

  .factory('$ionicCloudClient', [function() {
    return Ionic.client;
  }])

  .factory('$ionicUser', [function() {
    return Ionic.singleUserService.current();
  }])

  .factory('$ionicAuth', [function() {
    return Ionic.auth;
  }])

  .factory('$ionicPush', [function() {
    return Ionic.push;
  }])

  .factory('$ionicDeploy', [function() {
    return Ionic.deploy;
  }])

  .run(['$window', '$q', function($window, $q) {
    if (typeof $window.Promise === 'undefined') {
      $window.Promise = $q;
    } else {
      var init = Ionic.Cloud.DeferredPromise.prototype.init;

      Ionic.Cloud.DeferredPromise.prototype.init = function() {
        init.apply(this, arguments);
        this.promise = $q.when(this.promise);
      };
    }
  }]);

}

},{}],27:[function(require,module,exports){
var Core = require("./../dist/es5/core").Core;
var DataType = require("./../dist/es5/user/data-types").DataType;
var Deploy = require("./../dist/es5/deploy/deploy").Deploy;
var EventEmitter = require("./../dist/es5/events").EventEmitter;
var Logger = require("./../dist/es5/logger").Logger;
var Push = require("./../dist/es5/push/push").Push;
var PushMessage = require("./../dist/es5/push/message").PushMessage;
var auth = require("./../dist/es5/auth");
var client = require("./../dist/es5/client");
var config = require("./../dist/es5/config");
var cordova = require("./../dist/es5/cordova");
var device = require("./../dist/es5/device");
var di = require("./../dist/es5/di");
var promise = require("./../dist/es5/promise");
var storage = require("./../dist/es5/storage");
var user = require("./../dist/es5/user/user");

// Declare the window object
window.Ionic = new di.Container();

// Ionic Modules
Ionic.Core = Core;
Ionic.User = user.User;
Ionic.Auth = auth.Auth;
Ionic.Deploy = Deploy;
Ionic.Push = Push;
Ionic.PushMessage = PushMessage;

// DataType Namespace
Ionic.DataType = DataType;
Ionic.DataTypes = DataType.getMapping();

// Cloud Namespace
Ionic.Cloud = {};
Ionic.Cloud.AuthType = auth.AuthType;
Ionic.Cloud.AuthTypes = {};
Ionic.Cloud.AuthTypes.BasicAuth = auth.BasicAuth;
Ionic.Cloud.AuthTypes.CustomAuth = auth.CustomAuth;
Ionic.Cloud.AuthTypes.TwitterAuth = auth.TwitterAuth;
Ionic.Cloud.AuthTypes.FacebookAuth = auth.FacebookAuth;
Ionic.Cloud.AuthTypes.GithubAuth = auth.GithubAuth;
Ionic.Cloud.AuthTypes.GoogleAuth = auth.GoogleAuth;
Ionic.Cloud.AuthTypes.InstagramAuth = auth.InstagramAuth;
Ionic.Cloud.AuthTypes.LinkedInAuth = auth.LinkedInAuth;
Ionic.Cloud.Cordova = cordova.Cordova;
Ionic.Cloud.Client = client.Client;
Ionic.Cloud.Device = device.Device;
Ionic.Cloud.EventEmitter = EventEmitter;
Ionic.Cloud.Logger = Logger;
Ionic.Cloud.DeferredPromise = promise.DeferredPromise;
Ionic.Cloud.Storage = storage.Storage;
Ionic.Cloud.UserContext = user.UserContext;
Ionic.Cloud.SingleUserService = user.SingleUserService;
Ionic.Cloud.AuthTokenContext = auth.AuthTokenContext;
Ionic.Cloud.CombinedAuthTokenContext = auth.CombinedAuthTokenContext;
Ionic.Cloud.LocalStorageStrategy = storage.LocalStorageStrategy;
Ionic.Cloud.SessionStorageStrategy = storage.SessionStorageStrategy;
Ionic.Cloud.Config = config.Config;

},{"./../dist/es5/auth":1,"./../dist/es5/client":2,"./../dist/es5/config":3,"./../dist/es5/cordova":4,"./../dist/es5/core":5,"./../dist/es5/deploy/deploy":6,"./../dist/es5/device":7,"./../dist/es5/di":8,"./../dist/es5/events":10,"./../dist/es5/logger":13,"./../dist/es5/promise":14,"./../dist/es5/push/message":15,"./../dist/es5/push/push":16,"./../dist/es5/storage":17,"./../dist/es5/user/data-types":18,"./../dist/es5/user/user":19}]},{},[27,26,11])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2VzNS9hdXRoLmpzIiwiZGlzdC9lczUvY2xpZW50LmpzIiwiZGlzdC9lczUvY29uZmlnLmpzIiwiZGlzdC9lczUvY29yZG92YS5qcyIsImRpc3QvZXM1L2NvcmUuanMiLCJkaXN0L2VzNS9kZXBsb3kvZGVwbG95LmpzIiwiZGlzdC9lczUvZGV2aWNlLmpzIiwiZGlzdC9lczUvZGkuanMiLCJkaXN0L2VzNS9lcnJvcnMuanMiLCJkaXN0L2VzNS9ldmVudHMuanMiLCJkaXN0L2VzNS9pbmRleC5qcyIsImRpc3QvZXM1L2luc2lnaHRzLmpzIiwiZGlzdC9lczUvbG9nZ2VyLmpzIiwiZGlzdC9lczUvcHJvbWlzZS5qcyIsImRpc3QvZXM1L3B1c2gvbWVzc2FnZS5qcyIsImRpc3QvZXM1L3B1c2gvcHVzaC5qcyIsImRpc3QvZXM1L3N0b3JhZ2UuanMiLCJkaXN0L2VzNS91c2VyL2RhdGEtdHlwZXMuanMiLCJkaXN0L2VzNS91c2VyL3VzZXIuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVkdWNlLWNvbXBvbmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LmpzIiwic3JjL2FuZ3VsYXIuanMiLCJzcmMvZXM1LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHByb21pc2VfMSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBBdXRoVG9rZW5Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoVG9rZW5Db250ZXh0KGRlcHMsIGxhYmVsKSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gZGVwcy5zdG9yYWdlO1xuICAgIH1cbiAgICBBdXRoVG9rZW5Db250ZXh0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0KHRoaXMubGFiZWwpO1xuICAgIH07XG4gICAgQXV0aFRva2VuQ29udGV4dC5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh0aGlzLmxhYmVsLCB0b2tlbik7XG4gICAgfTtcbiAgICBBdXRoVG9rZW5Db250ZXh0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5kZWxldGUodGhpcy5sYWJlbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXV0aFRva2VuQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLkF1dGhUb2tlbkNvbnRleHQgPSBBdXRoVG9rZW5Db250ZXh0O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBDb21iaW5lZEF1dGhUb2tlbkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbWJpbmVkQXV0aFRva2VuQ29udGV4dChkZXBzLCBsYWJlbCkge1xuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IGRlcHMuc3RvcmFnZTtcbiAgICAgICAgdGhpcy50ZW1wU3RvcmFnZSA9IGRlcHMudGVtcFN0b3JhZ2U7XG4gICAgfVxuICAgIENvbWJpbmVkQXV0aFRva2VuQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGVybVRva2VuID0gdGhpcy5zdG9yYWdlLmdldCh0aGlzLmxhYmVsKTtcbiAgICAgICAgdmFyIHRlbXBUb2tlbiA9IHRoaXMudGVtcFN0b3JhZ2UuZ2V0KHRoaXMubGFiZWwpO1xuICAgICAgICB2YXIgdG9rZW4gPSB0ZW1wVG9rZW4gfHwgcGVybVRva2VuO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICBDb21iaW5lZEF1dGhUb2tlbkNvbnRleHQucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24gKHRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgJ3Blcm1hbmVudCc6IHRydWUgfTsgfVxuICAgICAgICBpZiAob3B0aW9ucy5wZXJtYW5lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQodGhpcy5sYWJlbCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZW1wU3RvcmFnZS5zZXQodGhpcy5sYWJlbCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21iaW5lZEF1dGhUb2tlbkNvbnRleHQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLmRlbGV0ZSh0aGlzLmxhYmVsKTtcbiAgICAgICAgdGhpcy50ZW1wU3RvcmFnZS5kZWxldGUodGhpcy5sYWJlbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tYmluZWRBdXRoVG9rZW5Db250ZXh0O1xufSgpKTtcbmV4cG9ydHMuQ29tYmluZWRBdXRoVG9rZW5Db250ZXh0ID0gQ29tYmluZWRBdXRoVG9rZW5Db250ZXh0O1xuLyoqXG4gKiBgQXV0aGAgaGFuZGxlcyBhdXRoZW50aWNhdGlvbiBvZiBhIHNpbmdsZSB1c2VyLCBzdWNoIGFzIHNpZ25pbmcgdXAsIGxvZ2dpbmdcbiAqIGluICYgb3V0LCBzb2NpYWwgcHJvdmlkZXIgYXV0aGVudGljYXRpb24sIGV0Yy5cbiAqXG4gKiBAZmVhdHVyZWRcbiAqL1xudmFyIEF1dGggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGgoZGVwcywgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZGVwcy5jb25maWc7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGRlcHMuZW1pdHRlcjtcbiAgICAgICAgdGhpcy5hdXRoTW9kdWxlcyA9IGRlcHMuYXV0aE1vZHVsZXM7XG4gICAgICAgIHRoaXMudG9rZW5Db250ZXh0ID0gZGVwcy50b2tlbkNvbnRleHQ7XG4gICAgICAgIHRoaXMudXNlclNlcnZpY2UgPSBkZXBzLnVzZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBkZXBzLnN0b3JhZ2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRoLnByb3RvdHlwZSwgXCJwYXNzd29yZFJlc2V0VXJsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpbmsgdGhlIHVzZXIgdG8gdGhpcyBVUkwgZm9yIHBhc3N3b3JkIHJlc2V0cy4gT25seSBmb3IgZW1haWwvcGFzc3dvcmRcbiAgICAgICAgICogYXV0aGVudGljYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIHVzZSBvdXIgcGFzc3dvcmQgcmVzZXQgZm9ybXMgaW5zdGVhZCBvZiBjcmVhdGluZ1xuICAgICAgICAgKiB5b3VyIG93biBpbiB5b3VyIGFwcC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmdldFVSTCgnd2ViJykgKyBcIi9wYXNzd29yZC9yZXNldC9cIiArIHRoaXMuY29uZmlnLmdldCgnYXBwX2lkJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaXMgbG9nZ2VkIGluIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIElmIGFuIGF1dGggdG9rZW4gZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UsIHRoZSB1c2VyIGlzIGxvZ2dlZCBpbi5cbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5pc0F1dGhlbnRpY2F0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5Db250ZXh0LmdldCgpO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpZ24gdXAgYSB1c2VyIHdpdGggdGhlIGdpdmVuIGRhdGEuIE9ubHkgZm9yIGVtYWlsL3Bhc3N3b3JkXG4gICAgICogYXV0aGVudGljYXRpb24uXG4gICAgICpcbiAgICAgKiBgc2lnbnVwYCBkb2VzIG5vdCBhZmZlY3QgbG9jYWwgZGF0YSBvciB0aGUgY3VycmVudCB1c2VyIHVudGlsIGBsb2dpbmAgaXNcbiAgICAgKiBjYWxsZWQuIFRoaXMgbWVhbnMgeW91J2xsIGxpa2VseSB3YW50IHRvIGxvZyBpbiB5b3VyIHVzZXJzIG1hbnVhbGx5IGFmdGVyXG4gICAgICogc2lnbnVwLlxuICAgICAqXG4gICAgICogSWYgYSBzaWdudXAgZmFpbHMsIHRoZSBwcm9taXNlIHJlamVjdHMgd2l0aCBhIFtgSURldGFpbGVkRXJyb3JgXG4gICAgICogb2JqZWN0XSgvYXBpL2NsaWVudC9pZGV0YWlsZWRlcnJvcikgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBlcnJvciBjb2Rlc1xuICAgICAqIGZyb20gdGhlIGNsb3VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyB0aGF0IGRlc2NyaWJlIGEgdXNlci5cbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5zaWdudXAgPSBmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoTW9kdWxlcy5iYXNpYy5zaWdudXAoZGV0YWlscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGxvZyB0aGUgdXNlciBpbiB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy4gRm9yIGN1c3RvbSAmIHNvY2lhbFxuICAgICAqIGxvZ2lucywga2ljay1vZmYgdGhlIGF1dGhlbnRpY2F0aW9uIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBBZnRlciBsb2dpbiwgdGhlIGZ1bGwgdXNlciBpcyBsb2FkZWQgZnJvbSB0aGUgY2xvdWQgYW5kIHNhdmVkIGluIGxvY2FsXG4gICAgICogc3RvcmFnZSBhbG9uZyB3aXRoIHRoZWlyIGF1dGggdG9rZW4uXG4gICAgICpcbiAgICAgKiBAbm90ZSBUT0RPOiBCZXR0ZXIgZXJyb3IgaGFuZGxpbmcgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2R1bGVJZFxuICAgICAqICBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgbW9kdWxlIElEIHRvIHVzZSB3aXRoIHRoaXMgbG9naW4uXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxzXG4gICAgICogIEZvciBlbWFpbC9wYXNzd29yZCBhdXRoZW50aWNhdGlvbiwgZ2l2ZSBhbiBlbWFpbCBhbmQgcGFzc3dvcmQuIEZvciBzb2NpYWxcbiAgICAgKiAgYXV0aGVudGljYXRpb24sIGV4Y2x1ZGUgdGhpcyBwYXJhbWV0ZXIuIEZvciBjdXN0b20gYXV0aGVudGljYXRpb24sIHNlbmRcbiAgICAgKiAgd2hhdGV2ZXIgeW91IG5lZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiAgT3B0aW9ucyBmb3IgdGhpcyBsb2dpbiwgc3VjaCBhcyB3aGV0aGVyIHRvIHJlbWVtYmVyIHRoZSBsb2dpbiBhbmRcbiAgICAgKiAgSW5BcHBCcm93c2VyIHdpbmRvdyBvcHRpb25zIGZvciBhdXRoZW50aWNhdGlvbiBwcm92aWRlcnMgdGhhdCBtYWtlIHVzZSBvZlxuICAgICAqICBpdC5cbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlbWVtYmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb3B0aW9ucy5yZW1lbWJlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmluQXBwQnJvd3Nlck9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRpb25zLmluQXBwQnJvd3Nlck9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5BcHBCcm93c2VyT3B0aW9ucy5sb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaW5BcHBCcm93c2VyT3B0aW9ucy5sb2NhdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbkFwcEJyb3dzZXJPcHRpb25zLmNsZWFyY2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRpb25zLmluQXBwQnJvd3Nlck9wdGlvbnMuY2xlYXJjYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmluQXBwQnJvd3Nlck9wdGlvbnMuY2xlYXJzZXNzaW9uY2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRpb25zLmluQXBwQnJvd3Nlck9wdGlvbnMuY2xlYXJzZXNzaW9uY2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5hdXRoTW9kdWxlc1ttb2R1bGVJZF07XG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBjbGFzcyBpcyBpbnZhbGlkIG9yIG1pc3Npbmc6JyArIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LmF1dGhlbnRpY2F0ZShjcmVkZW50aWFscywgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgX3RoaXMuc3RvcmVUb2tlbihvcHRpb25zLCByLnRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy51c2VyU2VydmljZS5sb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBfdGhpcy51c2VyU2VydmljZS5jdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgdXNlci5zdG9yZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIHRoZSB1c2VyIG91dCBvZiB0aGUgYXBwLlxuICAgICAqXG4gICAgICogVGhpcyBjbGVhcnMgdGhlIGF1dGggdG9rZW4gb3V0IG9mIGxvY2FsIHN0b3JhZ2UgYW5kIHJlc3RvcmVzIHRoZSB1c2VyIHRvXG4gICAgICogYW4gdW5hdXRoZW50aWNhdGVkIHN0YXRlLlxuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmxvZ291dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b2tlbkNvbnRleHQuZGVsZXRlKCk7XG4gICAgICAgIHZhciB1c2VyID0gdGhpcy51c2VyU2VydmljZS5jdXJyZW50KCk7XG4gICAgICAgIHVzZXIudW5zdG9yZSgpO1xuICAgICAgICB1c2VyLmNsZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBLaWNrLW9mZiB0aGUgcGFzc3dvcmQgcmVzZXQgcHJvY2Vzcy4gT25seSBmb3IgZW1haWwvcGFzc3dvcmRcbiAgICAgKiBhdXRoZW50aWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEFuIGVtYWlsIHdpbGwgYmUgc2VudCB0byB0aGUgdXNlciB3aXRoIGEgc2hvcnQgcGFzc3dvcmQgcmVzZXQgY29kZSwgd2hpY2hcbiAgICAgKiB0aGV5IGNhbiBjb3B5IGJhY2sgaW50byB5b3VyIGFwcCBhbmQgdXNlIHRoZSBbYGNvbmZpcm1QYXNzd29yZFJlc2V0KClgXG4gICAgICogbWV0aG9kXSgjY29uZmlybVBhc3N3b3JkUmVzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIC0gVGhlIGVtYWlsIGFkZHJlc3MgdG8gd2hpY2ggdG8gc2VuZCBhIGNvZGUuXG4gICAgICovXG4gICAgQXV0aC5wcm90b3R5cGUucmVxdWVzdFBhc3N3b3JkUmVzZXQgPSBmdW5jdGlvbiAoZW1haWwpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCgnYXV0aF9wYXNzd29yZF9yZXNldF9lbWFpbCcsIGVtYWlsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aE1vZHVsZXMuYmFzaWMucmVxdWVzdFBhc3N3b3JkUmVzZXQoZW1haWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZmlybSBhIHBhc3N3b3JkIHJlc2V0LlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgdXNlciBnaXZlcyB5b3UgdGhlaXIgcGFzc3dvcmQgcmVzZXQgY29kZSBpbnRvIHlvdXIgYXBwIGFuZCB0aGVpclxuICAgICAqIHJlcXVlc3RlZCBjaGFuZ2VkIHBhc3N3b3JkLCBjYWxsIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgLSBUaGUgcGFzc3dvcmQgcmVzZXQgY29kZSBmcm9tIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSByZXF1ZXN0ZWQgY2hhbmdlZCBwYXNzd29yZCBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmNvbmZpcm1QYXNzd29yZFJlc2V0ID0gZnVuY3Rpb24gKGNvZGUsIG5ld1Bhc3N3b3JkKSB7XG4gICAgICAgIHZhciBlbWFpbCA9IHRoaXMuc3RvcmFnZS5nZXQoJ2F1dGhfcGFzc3dvcmRfcmVzZXRfZW1haWwnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aE1vZHVsZXMuYmFzaWMuY29uZmlybVBhc3N3b3JkUmVzZXQoZW1haWwsIGNvZGUsIG5ld1Bhc3N3b3JkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmF3IGF1dGggdG9rZW4gb2YgdGhlIGFjdGl2ZSB1c2VyIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5Db250ZXh0LmdldCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLnN0b3JlVG9rZW4gPSBmdW5jdGlvbiAob3B0aW9ucywgdG9rZW4pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyAncmVtZW1iZXInOiB0cnVlIH07IH1cbiAgICAgICAgdmFyIG9yaWdpbmFsVG9rZW4gPSB0aGlzLmF1dGhUb2tlbjtcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbkNvbnRleHQuc3RvcmUodGhpcy5hdXRoVG9rZW4sIHsgJ3Blcm1hbmVudCc6IG9wdGlvbnMucmVtZW1iZXIgfSk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KCdhdXRoOnRva2VuLWNoYW5nZWQnLCB7ICdvbGQnOiBvcmlnaW5hbFRva2VuLCAnbmV3JzogdGhpcy5hdXRoVG9rZW4gfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQXV0aC5nZXREZXRhaWxlZEVycm9yRnJvbVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciBkZXRhaWxzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZXRhaWxzID0gcmVzLmJvZHkuZXJyb3IuZGV0YWlscztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGV0YWlscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRldGFpbCA9IGRldGFpbHNbaV07XG4gICAgICAgICAgICBpZiAoZGV0YWlsLmVycm9yX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChkZXRhaWwuZXJyb3JfdHlwZSArICdfJyArIGRldGFpbC5wYXJhbWV0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3JzXzEuRGV0YWlsZWRFcnJvcignRXJyb3IgY3JlYXRpbmcgdXNlcicsIGVycm9ycyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXV0aDtcbn0oKSk7XG5leHBvcnRzLkF1dGggPSBBdXRoO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBBdXRoVHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXV0aFR5cGUoZGVwcykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGRlcHMuY29uZmlnO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGRlcHMuY2xpZW50O1xuICAgIH1cbiAgICBBdXRoVHlwZS5wcm90b3R5cGUucGFyc2VJbkFwcEJyb3dzZXJPcHRpb25zID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvcHRzKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0c1trXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgdiA9IG9wdHNba10gPyAneWVzJyA6ICdubyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gb3B0c1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucHVzaChrICsgXCI9XCIgKyB2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC5qb2luKCcsJyk7XG4gICAgfTtcbiAgICBBdXRoVHlwZS5wcm90b3R5cGUuaW5BcHBCcm93c2VyRmxvdyA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSB7fTsgfVxuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmNvcmRvdmEgfHwgIXdpbmRvdy5jb3Jkb3ZhLkluQXBwQnJvd3Nlcikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcignSW5BcHBCcm93c2VyIHBsdWdpbiBtaXNzaW5nJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQucG9zdChcIi9hdXRoL2xvZ2luL1wiICsgbW9kdWxlSWQpXG4gICAgICAgICAgICAgICAgLnNlbmQoe1xuICAgICAgICAgICAgICAgICdhcHBfaWQnOiB0aGlzLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLFxuICAgICAgICAgICAgICAgICdjYWxsYmFjayc6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgICdkYXRhJzogZGF0YVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd18xID0gd2luZG93LmNvcmRvdmEuSW5BcHBCcm93c2VyLm9wZW4ocmVzLmJvZHkuZGF0YS51cmwsICdfYmxhbmsnLCBfdGhpcy5wYXJzZUluQXBwQnJvd3Nlck9wdGlvbnMob3B0aW9ucy5pbkFwcEJyb3dzZXJPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkV4aXRfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoJ0luQXBwQnJvd3NlciBleGl0JykpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgb25Mb2FkRXJyb3JfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoJ0luQXBwQnJvd3NlciBsb2FkZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkxvYWRTdGFydCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS51cmwuc2xpY2UoMCwgMjApID09PSAnaHR0cDovL2F1dGguaW9uaWMuaW8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gZGF0YS51cmwuc3BsaXQoJyMnKVswXS5zcGxpdCgnPycpWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbVBhcnRzID0gcXVlcnlTdHJpbmcuc3BsaXQoJyYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFyYW1QYXJ0c1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbcGFydFswXV0gPSBwYXJ0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3XzEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXhpdCcsIG9uRXhpdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3XzEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVycm9yJywgb25Mb2FkRXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd18xLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbic6IHBhcmFtc1sndG9rZW4nXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ251cCc6IEJvb2xlYW4ocGFyc2VJbnQocGFyYW1zWydzaWdudXAnXSwgMTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB3XzEuYWRkRXZlbnRMaXN0ZW5lcignZXhpdCcsIG9uRXhpdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgd18xLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlcnJvcicsIG9uTG9hZEVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICB3XzEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0Jywgb25Mb2FkU3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhUeXBlO1xufSgpKTtcbmV4cG9ydHMuQXV0aFR5cGUgPSBBdXRoVHlwZTtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQmFzaWNBdXRoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzaWNBdXRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2ljQXV0aCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJhc2ljQXV0aC5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgaWYgKCFkYXRhLmVtYWlsIHx8ICFkYXRhLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKCdlbWFpbCBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvbicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LnBvc3QoJy9hdXRoL2xvZ2luJylcbiAgICAgICAgICAgICAgICAuc2VuZCh7XG4gICAgICAgICAgICAgICAgJ2FwcF9pZCc6IHRoaXMuY29uZmlnLmdldCgnYXBwX2lkJyksXG4gICAgICAgICAgICAgICAgJ2VtYWlsJzogZGF0YS5lbWFpbCxcbiAgICAgICAgICAgICAgICAncGFzc3dvcmQnOiBkYXRhLnBhc3N3b3JkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Rva2VuJzogcmVzLmJvZHkuZGF0YS50b2tlblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIEJhc2ljQXV0aC5wcm90b3R5cGUucmVxdWVzdFBhc3N3b3JkUmVzZXQgPSBmdW5jdGlvbiAoZW1haWwpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgaWYgKCFlbWFpbCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcignRW1haWwgaXMgcmVxdWlyZWQgZm9yIHBhc3N3b3JkIHJlc2V0IHJlcXVlc3QuJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQucG9zdCgnL3VzZXJzL3Bhc3N3b3JkL3Jlc2V0JylcbiAgICAgICAgICAgICAgICAuc2VuZCh7XG4gICAgICAgICAgICAgICAgJ2FwcF9pZCc6IHRoaXMuY29uZmlnLmdldCgnYXBwX2lkJyksXG4gICAgICAgICAgICAgICAgJ2VtYWlsJzogZW1haWwsXG4gICAgICAgICAgICAgICAgJ2Zsb3cnOiAnYXBwJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICBCYXNpY0F1dGgucHJvdG90eXBlLmNvbmZpcm1QYXNzd29yZFJlc2V0ID0gZnVuY3Rpb24gKGVtYWlsLCBjb2RlLCBuZXdQYXNzd29yZCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICBpZiAoIWNvZGUgfHwgIWVtYWlsIHx8ICFuZXdQYXNzd29yZCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcignQ29kZSwgbmV3IHBhc3N3b3JkLCBhbmQgZW1haWwgYXJlIHJlcXVpcmVkLicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LnBvc3QoJy91c2Vycy9wYXNzd29yZCcpXG4gICAgICAgICAgICAgICAgLnNlbmQoe1xuICAgICAgICAgICAgICAgICdyZXNldF90b2tlbic6IGNvZGUsXG4gICAgICAgICAgICAgICAgJ25ld19wYXNzd29yZCc6IG5ld1Bhc3N3b3JkLFxuICAgICAgICAgICAgICAgICdlbWFpbCc6IGVtYWlsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIEJhc2ljQXV0aC5wcm90b3R5cGUuc2lnbnVwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgdmFyIHVzZXJEYXRhID0ge1xuICAgICAgICAgICAgJ2FwcF9pZCc6IHRoaXMuY29uZmlnLmdldCgnYXBwX2lkJyksXG4gICAgICAgICAgICAnZW1haWwnOiBkYXRhLmVtYWlsLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkJzogZGF0YS5wYXNzd29yZFxuICAgICAgICB9O1xuICAgICAgICAvLyBvcHRpb25hbCBkZXRhaWxzXG4gICAgICAgIGlmIChkYXRhLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICB1c2VyRGF0YS51c2VybmFtZSA9IGRhdGEudXNlcm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuaW1hZ2UpIHtcbiAgICAgICAgICAgIHVzZXJEYXRhLmltYWdlID0gZGF0YS5pbWFnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5uYW1lKSB7XG4gICAgICAgICAgICB1c2VyRGF0YS5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmN1c3RvbSkge1xuICAgICAgICAgICAgdXNlckRhdGEuY3VzdG9tID0gZGF0YS5jdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQucG9zdCgnL3VzZXJzJylcbiAgICAgICAgICAgIC5zZW5kKHVzZXJEYXRhKVxuICAgICAgICAgICAgLmVuZChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoQXV0aC5nZXREZXRhaWxlZEVycm9yRnJvbVJlc3BvbnNlKGVyci5yZXNwb25zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzaWNBdXRoO1xufShBdXRoVHlwZSkpO1xuZXhwb3J0cy5CYXNpY0F1dGggPSBCYXNpY0F1dGg7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEN1c3RvbUF1dGggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDdXN0b21BdXRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUF1dGgoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBDdXN0b21BdXRoLnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbkFwcEJyb3dzZXJGbG93KCdjdXN0b20nLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21BdXRoO1xufShBdXRoVHlwZSkpO1xuZXhwb3J0cy5DdXN0b21BdXRoID0gQ3VzdG9tQXV0aDtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgVHdpdHRlckF1dGggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUd2l0dGVyQXV0aCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUd2l0dGVyQXV0aCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFR3aXR0ZXJBdXRoLnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbkFwcEJyb3dzZXJGbG93KCd0d2l0dGVyJywgZGF0YSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHdpdHRlckF1dGg7XG59KEF1dGhUeXBlKSk7XG5leHBvcnRzLlR3aXR0ZXJBdXRoID0gVHdpdHRlckF1dGg7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEZhY2Vib29rQXV0aCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZhY2Vib29rQXV0aCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGYWNlYm9va0F1dGgoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGYWNlYm9va0F1dGgucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLmluQXBwQnJvd3NlckZsb3coJ2ZhY2Vib29rJywgZGF0YSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gRmFjZWJvb2tBdXRoO1xufShBdXRoVHlwZSkpO1xuZXhwb3J0cy5GYWNlYm9va0F1dGggPSBGYWNlYm9va0F1dGg7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEdpdGh1YkF1dGggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHaXRodWJBdXRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdpdGh1YkF1dGgoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBHaXRodWJBdXRoLnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbkFwcEJyb3dzZXJGbG93KCdnaXRodWInLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBHaXRodWJBdXRoO1xufShBdXRoVHlwZSkpO1xuZXhwb3J0cy5HaXRodWJBdXRoID0gR2l0aHViQXV0aDtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgR29vZ2xlQXV0aCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdvb2dsZUF1dGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR29vZ2xlQXV0aCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEdvb2dsZUF1dGgucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLmluQXBwQnJvd3NlckZsb3coJ2dvb2dsZScsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEdvb2dsZUF1dGg7XG59KEF1dGhUeXBlKSk7XG5leHBvcnRzLkdvb2dsZUF1dGggPSBHb29nbGVBdXRoO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBJbnN0YWdyYW1BdXRoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5zdGFncmFtQXV0aCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnN0YWdyYW1BdXRoKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW5zdGFncmFtQXV0aC5wcm90b3R5cGUuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BcHBCcm93c2VyRmxvdygnaW5zdGFncmFtJywgZGF0YSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zdGFncmFtQXV0aDtcbn0oQXV0aFR5cGUpKTtcbmV4cG9ydHMuSW5zdGFncmFtQXV0aCA9IEluc3RhZ3JhbUF1dGg7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIExpbmtlZEluQXV0aCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmtlZEluQXV0aCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rZWRJbkF1dGgoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBMaW5rZWRJbkF1dGgucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLmluQXBwQnJvd3NlckZsb3coJ2xpbmtlZGluJywgZGF0YSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua2VkSW5BdXRoO1xufShBdXRoVHlwZSkpO1xuZXhwb3J0cy5MaW5rZWRJbkF1dGggPSBMaW5rZWRJbkF1dGg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciByZXF1ZXN0ID0gcmVxdWlyZSgnc3VwZXJhZ2VudCcpO1xuLyoqXG4gKiBgQ2xpZW50YCBpcyBmb3IgbWFraW5nIEhUVFAgcmVxdWVzdHMgdG8gdGhlIEFQSS5cbiAqXG4gKiBVbmRlciB0aGUgaG9vZCwgaXQgdXNlc1xuICogW3N1cGVyYWdlbnRdKGh0dHA6Ly92aXNpb25tZWRpYS5naXRodWIuaW8vc3VwZXJhZ2VudC8pLiBXaGVuIGEgbWV0aG9kIGlzXG4gKiBjYWxsZWQsIHlvdSBjYW4gY2FsbCBhbnkgbnVtYmVyIG9mIHN1cGVyYWdlbnQgZnVuY3Rpb25zIG9uIGl0IGFuZCB0aGVuIGNhbGxcbiAqIGBlbmQoKWAgdG8gY29tcGxldGUgYW5kIHNlbmQgdGhlIHJlcXVlc3QuXG4gKlxuICogQGZlYXR1cmVkXG4gKi9cbnZhciBDbGllbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsaWVudChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRva2VuQ29udGV4dCwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlVXJsLCByZXEgLy8gVE9ETzogdXNlIHN1cGVyYWdlbnQgdHlwZXNcbiAgICAgICAgKSB7XG4gICAgICAgIHRoaXMudG9rZW5Db250ZXh0ID0gdG9rZW5Db250ZXh0O1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgICBpZiAodHlwZW9mIHJlcSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlcSA9IHJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdFVCByZXF1ZXN0IGZvciByZXRyaWV2aW5nIGEgcmVzb3VyY2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZHBvaW50IC0gVGhlIHBhdGggb2YgdGhlIEFQSSBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwbGVtZW50KHRoaXMucmVxLmdldCwgZW5kcG9pbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUE9TVCByZXF1ZXN0IGZvciBzZW5kaW5nIGEgbmV3IHJlc291cmNlIHRvIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5kcG9pbnQgLSBUaGUgcGF0aCBvZiB0aGUgQVBJIGVuZHBvaW50LlxuICAgICAqL1xuICAgIENsaWVudC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwbGVtZW50KHRoaXMucmVxLnBvc3QsIGVuZHBvaW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBVVCByZXF1ZXN0IGZvciByZXBsYWNpbmcgYSByZXNvdXJjZSBpbiB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZHBvaW50IC0gVGhlIHBhdGggb2YgdGhlIEFQSSBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwbGVtZW50KHRoaXMucmVxLnB1dCwgZW5kcG9pbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUEFUQ0ggcmVxdWVzdCBmb3IgcGVyZm9ybWluZyBwYXJ0aWFsIHVwZGF0ZXMgdG8gYSByZXNvdXJjZSBpbiB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZHBvaW50IC0gVGhlIHBhdGggb2YgdGhlIEFQSSBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKGVuZHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBsZW1lbnQodGhpcy5yZXEucGF0Y2gsIGVuZHBvaW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERFTEVURSByZXF1ZXN0IGZvciBkZWxldGluZyBhIHJlc291cmNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmRwb2ludCAtIFRoZSBwYXRoIG9mIHRoZSBBUEkgZW5kcG9pbnQuXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcGxlbWVudCh0aGlzLnJlcS5kZWxldGUsIGVuZHBvaW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBDbGllbnQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBwbGVtZW50KHRoaXMucmVxLmJpbmQodGhpcy5yZXEsIG1ldGhvZCksIGVuZHBvaW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ2xpZW50LnByb3RvdHlwZS5zdXBwbGVtZW50ID0gZnVuY3Rpb24gKGZuLCBlbmRwb2ludCkge1xuICAgICAgICBpZiAoZW5kcG9pbnQuc3Vic3RyaW5nKDAsIDEpICE9PSAnLycpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmRwb2ludCBtdXN0IHN0YXJ0IHdpdGggbGVhZGluZyBzbGFzaCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXEgPSBmbih0aGlzLmJhc2VVcmwgKyBlbmRwb2ludCk7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMudG9rZW5Db250ZXh0LmdldCgpO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJlcS5zZXQoJ0F1dGhvcml6YXRpb24nLCBcIkJlYXJlciBcIiArIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmZpZygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybHMgPSB7XG4gICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmlvbmljLmlvJyxcbiAgICAgICAgICAgICd3ZWInOiAnaHR0cHM6Ly93ZWIuaW9uaWMuaW8nXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IGNvbmZpZy5cbiAgICAgKi9cbiAgICBDb25maWcucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhIHZhbHVlIGZyb20gdGhlIGNvcmUgc2V0dGluZ3MuIFlvdSBzaG91bGQgdXNlIGBzZXR0aW5nc2AgYXR0cmlidXRlXG4gICAgICogZGlyZWN0bHkgZm9yIGNvcmUgc2V0dGluZ3MgYW5kIG90aGVyIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIHNldHRpbmdzIGtleSB0byBnZXQuXG4gICAgICovXG4gICAgQ29uZmlnLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MgfHwgIXRoaXMuc2V0dGluZ3MuY29yZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5jb3JlW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIENvbmZpZy5wcm90b3R5cGUuZ2V0VVJMID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHVybHMgPSAodGhpcy5zZXR0aW5ncyAmJiB0aGlzLnNldHRpbmdzLmNvcmUgJiYgdGhpcy5zZXR0aW5ncy5jb3JlLnVybHMpIHx8IHt9O1xuICAgICAgICBpZiAodXJsc1tuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHVybHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXJsc1tuYW1lXTtcbiAgICB9O1xuICAgIHJldHVybiBDb25maWc7XG59KCkpO1xuZXhwb3J0cy5Db25maWcgPSBDb25maWc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQ29yZG92YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29yZG92YShkZXBzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXBwID0gZGVwcy5hcHBTdGF0dXM7XG4gICAgICAgIHRoaXMuZGV2aWNlID0gZGVwcy5kZXZpY2U7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGRlcHMuZW1pdHRlcjtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBkZXBzLmxvZ2dlcjtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcbiAgICB9XG4gICAgQ29yZG92YS5wcm90b3R5cGUuYm9vdHN0cmFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXZlbnRzID0gWydwYXVzZScsICdyZXN1bWUnXTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci5lbWl0KCdjb3Jkb3ZhOmRldmljZXJlYWR5JywgeyAnYXJncyc6IGFyZ3MgfSk7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci5lbWl0KCdjb3Jkb3ZhOicgKyBlLCB7ICdhcmdzJzogYXJncyB9KTtcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBldmVudHNfMSA9IGV2ZW50czsgX2EgPCBldmVudHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGV2ZW50c18xW19hXTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvcmRvdmEucHJvdG90eXBlLnJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9uKCdjb3Jkb3ZhOnBhdXNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYXBwLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXR0ZXIub24oJ2NvcmRvdmE6cmVzdW1lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYXBwLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb3Jkb3ZhO1xufSgpKTtcbmV4cG9ydHMuQ29yZG92YSA9IENvcmRvdmE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQ29yZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29yZShkZXBzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9ICcwLjguMCc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZGVwcy5jb25maWc7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZGVwcy5sb2dnZXI7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGRlcHMuZW1pdHRlcjtcbiAgICAgICAgdGhpcy5pbnNpZ2h0cyA9IGRlcHMuaW5zaWdodHM7XG4gICAgfVxuICAgIENvcmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMub25SZXN1bWUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlLnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5vblJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnNpZ2h0cy50cmFjaygnbW9iaWxlYXBwLm9wZW5lZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdHRlci5vbignY29yZG92YTpyZXN1bWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vblJlc3VtZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9uKCdwdXNoOm5vdGlmaWNhdGlvbicsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5tZXNzYWdlLmFwcC5hc2xlZXAgfHwgZGF0YS5tZXNzYWdlLmFwcC5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnNpZ2h0cy50cmFjaygnbW9iaWxlYXBwLm9wZW5lZC5wdXNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvcmU7XG59KCkpO1xuZXhwb3J0cy5Db3JlID0gQ29yZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb21pc2VfMSA9IHJlcXVpcmUoJy4uL3Byb21pc2UnKTtcbnZhciBOT19QTFVHSU4gPSBuZXcgRXJyb3IoJ01pc3NpbmcgZGVwbG95IHBsdWdpbjogYGlvbmljLXBsdWdpbi1kZXBsb3lgJyk7XG4vKipcbiAqIGBEZXBsb3lgIGhhbmRsZXMgbGl2ZSBkZXBsb3lzIG9mIHRoZSBhcHAuIERvd25sb2FkaW5nLCBleHRyYWN0aW5nLCBhbmRcbiAqIHJvbGxpbmcgYmFjayBzbmFwc2hvdHMuXG4gKlxuICogQGZlYXR1cmVkXG4gKi9cbnZhciBEZXBsb3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcGxveShkZXBzLCBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY3RpdmUgZGVwbG95IGNoYW5uZWwuIFNldCB0aGlzIHRvIGNoYW5nZSB0aGUgY2hhbm5lbCBvbiB3aGljaFxuICAgICAgICAgKiBgRGVwbG95YCBvcGVyYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9ICdwcm9kdWN0aW9uJztcbiAgICAgICAgdGhpcy5jb25maWcgPSBkZXBzLmNvbmZpZztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZGVwcy5lbWl0dGVyO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGRlcHMubG9nZ2VyO1xuICAgICAgICB0aGlzLmVtaXR0ZXIub25jZSgnZGV2aWNlOnJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9nZXRQbHVnaW4oKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBsdWdpbi5pbml0KF90aGlzLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLCBfdGhpcy5jb25maWcuZ2V0VVJMKCdhcGknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoJ2RlcGxveTpyZWFkeScpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIHVwZGF0ZXMgb24gdGhlIGFjdGl2ZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCBhIGJvb2xlYW4uIFdoZW4gYHRydWVgLCBhIG5ldyBzbmFwc2hvdCBleGlzdHMgb25cbiAgICAgKiB0aGUgY2hhbm5lbC5cbiAgICAgKi9cbiAgICBEZXBsb3kucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIub25jZSgnZGVwbG95OnJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9nZXRQbHVnaW4oKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBsdWdpbi5jaGVjayhfdGhpcy5jb25maWcuZ2V0KCdhcHBfaWQnKSwgX3RoaXMuY2hhbm5lbCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuaW5mbygnSW9uaWMgRGVwbG95OiBhbiB1cGRhdGUgaXMgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oJ0lvbmljIERlcGxveTogbm8gdXBkYXRlcyBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcignSW9uaWMgRGVwbG95OiBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBjaGVja2luZyBmb3IgdXBkYXRlcycpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5PX1BMVUdJTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvd25sb2FkIHRoZSBhdmFpbGFibGUgc25hcHNob3QuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAgICAgKiBbYGV4dHJhY3QoKWBdKC9hcGkvY2xpZW50L2RlcGxveS8jZXh0cmFjdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqICBPcHRpb25zIGZvciB0aGlzIGRvd25sb2FkLCBzdWNoIGFzIGEgcHJvZ3Jlc3MgY2FsbGJhY2suXG4gICAgICovXG4gICAgRGVwbG95LnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5vbmNlKCdkZXBsb3k6cmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luLmRvd25sb2FkKF90aGlzLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09ICd0cnVlJyAmJiByZXN1bHQgIT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uUHJvZ3Jlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5pbmZvKCdJb25pYyBEZXBsb3k6IGRvd25sb2FkIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5PX1BMVUdJTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIGRvd25sb2FkZWQgc25hcHNob3QuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgW2Bkb3dubG9hZCgpYF0oL2FwaS9jbGllbnQvZGVwbG95LyNkb3dubG9hZClcbiAgICAgKiBzdWNjZXNzZnVsbHkgcmVzb2x2ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlci5vbmNlKCdkZXBsb3k6cmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luLmV4dHJhY3QoX3RoaXMuY29uZmlnLmdldCgnYXBwX2lkJyksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gJ2RvbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblByb2dyZXNzKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuaW5mbygnSW9uaWMgRGVwbG95OiBleHRyYWN0aW9uIGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5PX1BMVUdJTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IHJlbG9hZCB0aGUgYXBwIHdpdGggdGhlIGxhdGVzdCBkZXBsb3llZCBzbmFwc2hvdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgdG8gY2FsbCBpZiB5b3UgaGF2ZSBkb3dubG9hZGVkIGFuZCBleHRyYWN0ZWQgYVxuICAgICAqIHNuYXBzaG90IGFuZCB3aXNoIHRvIGluc3RhbnRseSByZWxvYWQgdGhlIGFwcCB3aXRoIHRoZSBsYXRlc3QgZGVwbG95LiBUaGVcbiAgICAgKiBsYXRlc3QgZGVwbG95IHdpbGwgYXV0b21hdGljYWxseSBiZSBsb2FkZWQgd2hlbiB0aGUgYXBwIGlzIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgRGVwbG95LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIub25jZSgnZGVwbG95OnJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9nZXRQbHVnaW4oKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBsdWdpbi5yZWRpcmVjdChfdGhpcy5jb25maWcuZ2V0KCdhcHBfaWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHNuYXBzaG90LlxuICAgICAqXG4gICAgICogVGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhbiBvYmplY3QgdGhhdCBoYXMga2V5L3ZhbHVlIHBhaXJzIHBlcnRhaW5pbmdcbiAgICAgKiB0byB0aGUgY3VycmVudGx5IGRlcGxveWVkIHNuYXBzaG90LlxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTsgLy8gVE9ET1xuICAgICAgICB0aGlzLmVtaXR0ZXIub25jZSgnZGVwbG95OnJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9nZXRQbHVnaW4oKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnBsdWdpbi5pbmZvKF90aGlzLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5PX1BMVUdJTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3QgdGhlIHNuYXBzaG90cyB0aGF0IGhhdmUgYmVlbiBpbnN0YWxsZWQgb24gdGhpcyBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBUaGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIHNuYXBzaG90IFVVSURzLlxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuZ2V0U25hcHNob3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpOyAvLyBUT0RPXG4gICAgICAgIHRoaXMuZW1pdHRlci5vbmNlKCdkZXBsb3k6cmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luLmdldFZlcnNpb25zKF90aGlzLmNvbmZpZy5nZXQoJ2FwcF9pZCcpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE5PX1BMVUdJTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNuYXBzaG90IGZyb20gdGhpcyBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXVpZFxuICAgICAqICBUaGUgc25hcHNob3QgVVVJRCB0byByZW1vdmUgZnJvbSB0aGUgZGV2aWNlLlxuICAgICAqL1xuICAgIERlcGxveS5wcm90b3R5cGUuZGVsZXRlU25hcHNob3QgPSBmdW5jdGlvbiAodXVpZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgcHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpOyAvLyBUT0RPXG4gICAgICAgIHRoaXMuZW1pdHRlci5vbmNlKCdkZXBsb3k6cmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2dldFBsdWdpbigpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luLmRlbGV0ZVZlcnNpb24oX3RoaXMuY29uZmlnLmdldCgnYXBwX2lkJyksIHV1aWQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoTk9fUExVR0lOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbWV0YWRhdGEgZm9yIGEgZ2l2ZW4gc25hcHNob3QuIElmIG5vIFVVSUQgaXMgZ2l2ZW4sIGl0IHdpbGxcbiAgICAgKiBhdHRlbXB0IHRvIGdyYWIgdGhlIG1ldGFkYXRhIGZvciB0aGUgbW9zdCByZWNlbnRseSBrbm93biBzbmFwc2hvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dWlkXG4gICAgICogIFRoZSBzbmFwc2hvdCBmcm9tIHdoaWNoIHRvIGdyYWIgbWV0YWRhdGEuXG4gICAgICovXG4gICAgRGVwbG95LnByb3RvdHlwZS5nZXRNZXRhZGF0YSA9IGZ1bmN0aW9uICh1dWlkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7IC8vIFRPRE9cbiAgICAgICAgdGhpcy5lbWl0dGVyLm9uY2UoJ2RlcGxveTpyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZ2V0UGx1Z2luKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wbHVnaW4uZ2V0TWV0YWRhdGEoX3RoaXMuY29uZmlnLmdldCgnYXBwX2lkJyksIHV1aWQsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQubWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoTk9fUExVR0lOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEZXBsb3kucHJvdG90eXBlLl9nZXRQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LklvbmljRGVwbG95ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignSW9uaWMgRGVwbG95OiBEaXNhYmxlZCEgRGVwbG95IHBsdWdpbiBpcyBub3QgaW5zdGFsbGVkIG9yIGhhcyBub3QgbG9hZGVkLiBIYXZlIHlvdSBydW4gYGlvbmljIHBsdWdpbiBhZGQgaW9uaWMtcGx1Z2luLWRlcGxveWAgeWV0PycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wbHVnaW4pIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luID0gd2luZG93LklvbmljRGVwbG95O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbjtcbiAgICB9O1xuICAgIHJldHVybiBEZXBsb3k7XG59KCkpO1xuZXhwb3J0cy5EZXBsb3kgPSBEZXBsb3k7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgRGV2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXZpY2UoZGVwcykge1xuICAgICAgICB0aGlzLmRlcHMgPSBkZXBzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSB0aGlzLmRlcHMuZW1pdHRlcjtcbiAgICAgICAgdGhpcy5kZXZpY2VUeXBlID0gdGhpcy5kZXRlcm1pbmVEZXZpY2VUeXBlKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfVxuICAgIERldmljZS5wcm90b3R5cGUuaXNBbmRyb2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXZpY2VUeXBlID09PSAnYW5kcm9pZCc7XG4gICAgfTtcbiAgICBEZXZpY2UucHJvdG90eXBlLmlzSU9TID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXZpY2VUeXBlID09PSAnaXBob25lJyB8fCB0aGlzLmRldmljZVR5cGUgPT09ICdpcGFkJztcbiAgICB9O1xuICAgIERldmljZS5wcm90b3R5cGUuaXNDb25uZWN0ZWRUb05ldHdvcmsgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvci5jb25uZWN0aW9uID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgdHlwZW9mIG5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChuYXZpZ2F0b3IuY29ubmVjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rpb24uRVRIRVJORVQ6XG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rpb24uV0lGSTpcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdGlvbi5DRUxMXzJHOlxuICAgICAgICAgICAgY2FzZSBDb25uZWN0aW9uLkNFTExfM0c6XG4gICAgICAgICAgICBjYXNlIENvbm5lY3Rpb24uQ0VMTF80RzpcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdGlvbi5DRUxMOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRldmljZVR5cGUgPT09ICd1bmtub3duJykge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoJ2RldmljZTpyZWFkeScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLm9uY2UoJ2NvcmRvdmE6ZGV2aWNlcmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci5lbWl0KCdkZXZpY2U6cmVhZHknKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuZGV0ZXJtaW5lRGV2aWNlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgdmFyIGlwYWQgPSBhZ2VudC5tYXRjaCgvaVBhZC9pKTtcbiAgICAgICAgaWYgKGlwYWQgJiYgKGlwYWRbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ2lwYWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdpcGFkJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXBob25lID0gYWdlbnQubWF0Y2goL2lQaG9uZS9pKTtcbiAgICAgICAgaWYgKGlwaG9uZSAmJiAoaXBob25lWzBdLnRvTG93ZXJDYXNlKCkgPT09ICdpcGhvbmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdpcGhvbmUnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmRyb2lkID0gYWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG4gICAgICAgIGlmIChhbmRyb2lkICYmIChhbmRyb2lkWzBdLnRvTG93ZXJDYXNlKCkgPT09ICdhbmRyb2lkJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnYW5kcm9pZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICB9O1xuICAgIHJldHVybiBEZXZpY2U7XG59KCkpO1xuZXhwb3J0cy5EZXZpY2UgPSBEZXZpY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgYXV0aF8xID0gcmVxdWlyZSgnLi9hdXRoJyk7XG52YXIgY2xpZW50XzEgPSByZXF1aXJlKCcuL2NsaWVudCcpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciBjb3Jkb3ZhXzEgPSByZXF1aXJlKCcuL2NvcmRvdmEnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBkZXBsb3lfMSA9IHJlcXVpcmUoJy4vZGVwbG95L2RlcGxveScpO1xudmFyIGRldmljZV8xID0gcmVxdWlyZSgnLi9kZXZpY2UnKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG52YXIgaW5zaWdodHNfMSA9IHJlcXVpcmUoJy4vaW5zaWdodHMnKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG52YXIgcHVzaF8xID0gcmVxdWlyZSgnLi9wdXNoL3B1c2gnKTtcbnZhciBzdG9yYWdlXzEgPSByZXF1aXJlKCcuL3N0b3JhZ2UnKTtcbnZhciB1c2VyXzEgPSByZXF1aXJlKCcuL3VzZXIvdXNlcicpO1xudmFyIG1vZHVsZXMgPSB7fTtcbmZ1bmN0aW9uIGNhY2hlKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlc1twcm9wZXJ0eUtleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIG1vZHVsZXNbcHJvcGVydHlLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZXNbcHJvcGVydHlLZXldO1xuICAgIH07XG4gICAgZGVzY3JpcHRvci5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250YWluZXIoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcImFwcFN0YXR1c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJ2FzbGVlcCc6IGZhbHNlLCAnY2xvc2VkJzogZmFsc2UgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbmZpZ18xLkNvbmZpZygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJldmVudEVtaXR0ZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcImxvZ2dlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBsb2dnZXJfMS5Mb2dnZXIodGhpcy5jb25maWcuc2V0dGluZ3MubG9nZ2VyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwibG9jYWxTdG9yYWdlU3RyYXRlZ3lcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RvcmFnZV8xLkxvY2FsU3RvcmFnZVN0cmF0ZWd5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcInNlc3Npb25TdG9yYWdlU3RyYXRlZ3lcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RvcmFnZV8xLlNlc3Npb25TdG9yYWdlU3RyYXRlZ3koKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiYXV0aFRva2VuQ29udGV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gJ2F1dGhfJyArIHRoaXMuY29uZmlnLmdldCgnYXBwX2lkJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGF1dGhfMS5Db21iaW5lZEF1dGhUb2tlbkNvbnRleHQoe1xuICAgICAgICAgICAgICAgICdzdG9yYWdlJzogbmV3IHN0b3JhZ2VfMS5TdG9yYWdlKHsgJ3N0cmF0ZWd5JzogdGhpcy5sb2NhbFN0b3JhZ2VTdHJhdGVneSB9KSxcbiAgICAgICAgICAgICAgICAndGVtcFN0b3JhZ2UnOiBuZXcgc3RvcmFnZV8xLlN0b3JhZ2UoeyAnc3RyYXRlZ3knOiB0aGlzLnNlc3Npb25TdG9yYWdlU3RyYXRlZ3kgfSlcbiAgICAgICAgICAgIH0sIGxhYmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNsaWVudF8xLkNsaWVudCh0aGlzLmF1dGhUb2tlbkNvbnRleHQsIHRoaXMuY29uZmlnLmdldFVSTCgnYXBpJykpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJpbnNpZ2h0c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnNpZ2h0c18xLkluc2lnaHRzKHtcbiAgICAgICAgICAgICAgICAnYXBwU3RhdHVzJzogdGhpcy5hcHBTdGF0dXMsXG4gICAgICAgICAgICAgICAgJ3N0b3JhZ2UnOiBuZXcgc3RvcmFnZV8xLlN0b3JhZ2UoeyAnc3RyYXRlZ3knOiB0aGlzLmxvY2FsU3RvcmFnZVN0cmF0ZWd5IH0pLFxuICAgICAgICAgICAgICAgICdjb25maWcnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAnY2xpZW50JzogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgJ2xvZ2dlcic6IHRoaXMubG9nZ2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiY29yZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuQ29yZSh7XG4gICAgICAgICAgICAgICAgJ2NvbmZpZyc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgICdsb2dnZXInOiB0aGlzLmxvZ2dlcixcbiAgICAgICAgICAgICAgICAnZW1pdHRlcic6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgICAgICdpbnNpZ2h0cyc6IHRoaXMuaW5zaWdodHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJkZXZpY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGV2aWNlXzEuRGV2aWNlKHsgJ2VtaXR0ZXInOiB0aGlzLmV2ZW50RW1pdHRlciB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiY29yZG92YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3Jkb3ZhXzEuQ29yZG92YSh7XG4gICAgICAgICAgICAgICAgJ2FwcFN0YXR1cyc6IHRoaXMuYXBwU3RhdHVzLFxuICAgICAgICAgICAgICAgICdkZXZpY2UnOiB0aGlzLmRldmljZSxcbiAgICAgICAgICAgICAgICAnZW1pdHRlcic6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgICAgICdsb2dnZXInOiB0aGlzLmxvZ2dlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcInVzZXJDb250ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHVzZXJfMS5Vc2VyQ29udGV4dCh7ICdzdG9yYWdlJzogbmV3IHN0b3JhZ2VfMS5TdG9yYWdlKHsgJ3N0cmF0ZWd5JzogdGhpcy5sb2NhbFN0b3JhZ2VTdHJhdGVneSB9KSwgJ2NvbmZpZyc6IHRoaXMuY29uZmlnIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzaW5nbGVVc2VyU2VydmljZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB1c2VyXzEuU2luZ2xlVXNlclNlcnZpY2UoeyAnY2xpZW50JzogdGhpcy5jbGllbnQsICdjb250ZXh0JzogdGhpcy51c2VyQ29udGV4dCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiYXV0aE1vZHVsZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2Jhc2ljJzogbmV3IGF1dGhfMS5CYXNpY0F1dGgoeyAnY29uZmlnJzogdGhpcy5jb25maWcsICdjbGllbnQnOiB0aGlzLmNsaWVudCB9KSxcbiAgICAgICAgICAgICAgICAnY3VzdG9tJzogbmV3IGF1dGhfMS5DdXN0b21BdXRoKHsgJ2NvbmZpZyc6IHRoaXMuY29uZmlnLCAnY2xpZW50JzogdGhpcy5jbGllbnQgfSksXG4gICAgICAgICAgICAgICAgJ3R3aXR0ZXInOiBuZXcgYXV0aF8xLlR3aXR0ZXJBdXRoKHsgJ2NvbmZpZyc6IHRoaXMuY29uZmlnLCAnY2xpZW50JzogdGhpcy5jbGllbnQgfSksXG4gICAgICAgICAgICAgICAgJ2ZhY2Vib29rJzogbmV3IGF1dGhfMS5GYWNlYm9va0F1dGgoeyAnY29uZmlnJzogdGhpcy5jb25maWcsICdjbGllbnQnOiB0aGlzLmNsaWVudCB9KSxcbiAgICAgICAgICAgICAgICAnZ2l0aHViJzogbmV3IGF1dGhfMS5HaXRodWJBdXRoKHsgJ2NvbmZpZyc6IHRoaXMuY29uZmlnLCAnY2xpZW50JzogdGhpcy5jbGllbnQgfSksXG4gICAgICAgICAgICAgICAgJ2dvb2dsZSc6IG5ldyBhdXRoXzEuR29vZ2xlQXV0aCh7ICdjb25maWcnOiB0aGlzLmNvbmZpZywgJ2NsaWVudCc6IHRoaXMuY2xpZW50IH0pLFxuICAgICAgICAgICAgICAgICdpbnN0YWdyYW0nOiBuZXcgYXV0aF8xLkluc3RhZ3JhbUF1dGgoeyAnY29uZmlnJzogdGhpcy5jb25maWcsICdjbGllbnQnOiB0aGlzLmNsaWVudCB9KSxcbiAgICAgICAgICAgICAgICAnbGlua2VkaW4nOiBuZXcgYXV0aF8xLkxpbmtlZEluQXV0aCh7ICdjb25maWcnOiB0aGlzLmNvbmZpZywgJ2NsaWVudCc6IHRoaXMuY2xpZW50IH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJhdXRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGF1dGhfMS5BdXRoKHtcbiAgICAgICAgICAgICAgICAnY29uZmlnJzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICAgICAgJ2VtaXR0ZXInOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgICAgICAnYXV0aE1vZHVsZXMnOiB0aGlzLmF1dGhNb2R1bGVzLFxuICAgICAgICAgICAgICAgICd0b2tlbkNvbnRleHQnOiB0aGlzLmF1dGhUb2tlbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgJ3VzZXJTZXJ2aWNlJzogdGhpcy5zaW5nbGVVc2VyU2VydmljZSxcbiAgICAgICAgICAgICAgICAnc3RvcmFnZSc6IG5ldyBzdG9yYWdlXzEuU3RvcmFnZSh7ICdzdHJhdGVneSc6IHRoaXMubG9jYWxTdG9yYWdlU3RyYXRlZ3kgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJwdXNoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHB1c2hfMS5QdXNoKHtcbiAgICAgICAgICAgICAgICAnY29uZmlnJzogY29uZmlnLFxuICAgICAgICAgICAgICAgICdhdXRoJzogdGhpcy5hdXRoLFxuICAgICAgICAgICAgICAgICd1c2VyU2VydmljZSc6IHRoaXMuc2luZ2xlVXNlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgJ2RldmljZSc6IHRoaXMuZGV2aWNlLFxuICAgICAgICAgICAgICAgICdjbGllbnQnOiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICAnZW1pdHRlcic6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgICAgICdzdG9yYWdlJzogbmV3IHN0b3JhZ2VfMS5TdG9yYWdlKHsgJ3N0cmF0ZWd5JzogdGhpcy5sb2NhbFN0b3JhZ2VTdHJhdGVneSB9KSxcbiAgICAgICAgICAgICAgICAnbG9nZ2VyJzogdGhpcy5sb2dnZXJcbiAgICAgICAgICAgIH0sIGNvbmZpZy5zZXR0aW5ncy5wdXNoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiZGVwbG95XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRlcGxveV8xLkRlcGxveSh7XG4gICAgICAgICAgICAgICAgJ2NvbmZpZyc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgICAgICdlbWl0dGVyJzogdGhpcy5ldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICAgICAgJ2xvZ2dlcic6IHRoaXMubG9nZ2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJhcHBTdGF0dXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJjb25maWdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJldmVudEVtaXR0ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJsb2dnZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJsb2NhbFN0b3JhZ2VTdHJhdGVneVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGUsIFxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb250YWluZXIucHJvdG90eXBlLCBcInNlc3Npb25TdG9yYWdlU3RyYXRlZ3lcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJhdXRoVG9rZW5Db250ZXh0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiY2xpZW50XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiaW5zaWdodHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJjb3JlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiZGV2aWNlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiY29yZG92YVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGUsIFxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb250YWluZXIucHJvdG90eXBlLCBcInVzZXJDb250ZXh0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwic2luZ2xlVXNlclNlcnZpY2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJhdXRoTW9kdWxlc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgY2FjaGUsIFxuICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb250YWluZXIucHJvdG90eXBlLCBcImF1dGhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGNhY2hlLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJwdXNoXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjYWNoZSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiZGVwbG95XCIsIG51bGwpO1xuICAgIHJldHVybiBDb250YWluZXI7XG59KCkpO1xuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdFeGNlcHRpb24nO1xuICAgICAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgICB9XG4gICAgRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuICAgIHJldHVybiBFeGNlcHRpb247XG59KEVycm9yKSk7XG5leHBvcnRzLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbi8qKlxuICogQW4gZXJyb3Igd2l0aCBnZW5lcmljIGVycm9yIGRldGFpbHMuXG4gKlxuICogRXJyb3IgZGV0YWlscyBjYW4gYmUgZXh0cmFjdGVkIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBgRGAuIEZvciBpbnN0YW5jZSxcbiAqIGlmIHRoZSB0eXBlIG9mIGBEYCBpcyBgc3RyaW5nW11gLCB5b3UgY2FuIGRvIHRoaXM6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyOiBJRGV0YWlsZWRFcnJvcjxzdHJpbmdbXT4pIHtcbiAqICAgZm9yIChsZXQgaSBpbiBlcnIuZGV0YWlscykge1xuICogICAgIGNvbnNvbGUuZXJyb3IoJ2dvdCBlcnJvciBjb2RlOiAnICsgaSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBmZWF0dXJlZFxuICovXG52YXIgRGV0YWlsZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERldGFpbGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGV0YWlsZWRFcnJvcihcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgbWVzc2FnZSwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXJyb3IgZGV0YWlscy5cbiAgICAgICAgICovXG4gICAgICAgIGRldGFpbHMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMubmFtZSA9ICdEZXRhaWxlZEVycm9yJztcbiAgICB9XG4gICAgcmV0dXJuIERldGFpbGVkRXJyb3I7XG59KEV4Y2VwdGlvbikpO1xuZXhwb3J0cy5EZXRhaWxlZEVycm9yID0gRGV0YWlsZWRFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBIHJlZ2lzdGVyZWQgZXZlbnQgcmVjZWl2ZXIuXG4gKi9cbnZhciBFdmVudFJlY2VpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudFJlY2VpdmVyKFxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gcmVnaXN0ZXJlZCBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50IHJlY2VpdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAga2V5LCBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWdpc3RlcmVkIG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZXZlbnQsIFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdHVhbCBjYWxsYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50UmVjZWl2ZXI7XG59KCkpO1xuZXhwb3J0cy5FdmVudFJlY2VpdmVyID0gRXZlbnRSZWNlaXZlcjtcbi8qKlxuICogU3RvcmVzIGNhbGxiYWNrcyBmb3IgcmVnaXN0ZXJlZCBldmVudHMuXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm4gPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRSZWNlaXZlcnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50c0VtaXR0ZWQgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgY2FsbGJhY2sgd2hpY2ggZ2V0cyB0cmlnZ2VyZWQgZXZlcnkgdGltZSB0aGUgZXZlbnQgaXNcbiAgICAgKiBmaXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiAgQSBjYWxsYmFjayB0byBhdHRhY2ggdG8gdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXZlbnRSZWNlaXZlcnNbZXZlbnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5ldmVudFJlY2VpdmVyc1tldmVudF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBuZXcgRXZlbnRSZWNlaXZlcih0aGlzLm4sIGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMubisrO1xuICAgICAgICB0aGlzLmV2ZW50UmVjZWl2ZXJzW2V2ZW50XVtyZWNlaXZlci5rZXldID0gcmVjZWl2ZXI7XG4gICAgICAgIHJldHVybiByZWNlaXZlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYW4gZXZlbnQgcmVjZWl2ZXIgcmV0dXJuZWQgZnJvbVxuICAgICAqIFtgb24oKWBdKC9hcGkvY2xpZW50L2V2ZW50ZW1pdHRlciNvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJcbiAgICAgKiAgVGhlIGV2ZW50IHJlY2VpdmVyLlxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ldmVudFJlY2VpdmVyc1tyZWNlaXZlci5ldmVudF0gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5ldmVudFJlY2VpdmVyc1tyZWNlaXZlci5ldmVudF1bcmVjZWl2ZXIua2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBldmVudCByZWNlaXZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50UmVjZWl2ZXJzW3JlY2VpdmVyLmV2ZW50XVtyZWNlaXZlci5rZXldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgY2FsbGJhY2sgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmx5IG9uY2UuIElmIHRoZSBldmVudCB3YXNcbiAgICAgKiB0cmlnZ2VyZWQgYmVmb3JlIHlvdXIgY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZCwgaXQgY2FsbHMgeW91ciBjYWxsYmFja1xuICAgICAqIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQG5vdGUgVE9ETzogRml4IHRoZSBkb2NzIGZvciAoKSA9PiB2b2lkIHN5bnRheC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqICBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiAgQSBjYWxsYmFjayB0byBhdHRhY2ggdG8gdGhpcyBldmVudC4gSXQgdGFrZXMgbm8gYXJndW1lbnRzLlxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZW1pdHRlZChldmVudCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5lbWl0dGVkKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50LiBDYWxsIGFsbCBjYWxsYmFja3MgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogIFRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogIEFuIG9iamVjdCB0byBwYXNzIHRvIGV2ZXJ5IGNhbGxiYWNrLlxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7IGRhdGEgPSBudWxsOyB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ldmVudFJlY2VpdmVyc1tldmVudF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVjZWl2ZXJzW2V2ZW50XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ldmVudHNFbWl0dGVkW2V2ZW50XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzRW1pdHRlZFtldmVudF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5ldmVudFJlY2VpdmVyc1tldmVudF0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZWNlaXZlcnNbZXZlbnRdW2tdLmhhbmRsZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHNFbWl0dGVkW2V2ZW50XSArPSAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY291bnQgb2YgdGhlIG51bWJlciBvZiB0aW1lcyBhbiBldmVudCBoYXMgYmVlbiB0cmlnZ2VyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiAgVGhlIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0dGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5ldmVudHNFbWl0dGVkW2V2ZW50XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50c0VtaXR0ZWRbZXZlbnRdO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGF1dGhfMSA9IHJlcXVpcmUoJy4vYXV0aCcpO1xuZXhwb3J0cy5BdXRoID0gYXV0aF8xLkF1dGg7XG5leHBvcnRzLkF1dGhUeXBlID0gYXV0aF8xLkF1dGhUeXBlO1xuZXhwb3J0cy5CYXNpY0F1dGggPSBhdXRoXzEuQmFzaWNBdXRoO1xuZXhwb3J0cy5DdXN0b21BdXRoID0gYXV0aF8xLkN1c3RvbUF1dGg7XG5leHBvcnRzLkZhY2Vib29rQXV0aCA9IGF1dGhfMS5GYWNlYm9va0F1dGg7XG5leHBvcnRzLkdpdGh1YkF1dGggPSBhdXRoXzEuR2l0aHViQXV0aDtcbmV4cG9ydHMuR29vZ2xlQXV0aCA9IGF1dGhfMS5Hb29nbGVBdXRoO1xuZXhwb3J0cy5JbnN0YWdyYW1BdXRoID0gYXV0aF8xLkluc3RhZ3JhbUF1dGg7XG5leHBvcnRzLkxpbmtlZEluQXV0aCA9IGF1dGhfMS5MaW5rZWRJbkF1dGg7XG5leHBvcnRzLlR3aXR0ZXJBdXRoID0gYXV0aF8xLlR3aXR0ZXJBdXRoO1xudmFyIGNsaWVudF8xID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcbmV4cG9ydHMuQ2xpZW50ID0gY2xpZW50XzEuQ2xpZW50O1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmV4cG9ydHMuQ29uZmlnID0gY29uZmlnXzEuQ29uZmlnO1xudmFyIGNvcmRvdmFfMSA9IHJlcXVpcmUoJy4vY29yZG92YScpO1xuZXhwb3J0cy5Db3Jkb3ZhID0gY29yZG92YV8xLkNvcmRvdmE7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5leHBvcnRzLkNvcmUgPSBjb3JlXzEuQ29yZTtcbnZhciBkZXBsb3lfMSA9IHJlcXVpcmUoJy4vZGVwbG95L2RlcGxveScpO1xuZXhwb3J0cy5EZXBsb3kgPSBkZXBsb3lfMS5EZXBsb3k7XG52YXIgZGV2aWNlXzEgPSByZXF1aXJlKCcuL2RldmljZScpO1xuZXhwb3J0cy5EZXZpY2UgPSBkZXZpY2VfMS5EZXZpY2U7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuZXhwb3J0cy5FeGNlcHRpb24gPSBlcnJvcnNfMS5FeGNlcHRpb247XG5leHBvcnRzLkRldGFpbGVkRXJyb3IgPSBlcnJvcnNfMS5EZXRhaWxlZEVycm9yO1xudmFyIGRpXzEgPSByZXF1aXJlKCcuL2RpJyk7XG5leHBvcnRzLkRJQ29udGFpbmVyID0gZGlfMS5Db250YWluZXI7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBldmVudHNfMS5FdmVudEVtaXR0ZXI7XG52YXIgaW5zaWdodHNfMSA9IHJlcXVpcmUoJy4vaW5zaWdodHMnKTtcbmV4cG9ydHMuSW5zaWdodHMgPSBpbnNpZ2h0c18xLkluc2lnaHRzO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbmV4cG9ydHMuTG9nZ2VyID0gbG9nZ2VyXzEuTG9nZ2VyO1xudmFyIHB1c2hfMSA9IHJlcXVpcmUoJy4vcHVzaC9wdXNoJyk7XG5leHBvcnRzLlB1c2ggPSBwdXNoXzEuUHVzaDtcbnZhciBtZXNzYWdlXzEgPSByZXF1aXJlKCcuL3B1c2gvbWVzc2FnZScpO1xuZXhwb3J0cy5QdXNoTWVzc2FnZSA9IG1lc3NhZ2VfMS5QdXNoTWVzc2FnZTtcbnZhciBzdG9yYWdlXzEgPSByZXF1aXJlKCcuL3N0b3JhZ2UnKTtcbmV4cG9ydHMuU3RvcmFnZSA9IHN0b3JhZ2VfMS5TdG9yYWdlO1xuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VTdHJhdGVneSA9IHN0b3JhZ2VfMS5Mb2NhbFN0b3JhZ2VTdHJhdGVneTtcbmV4cG9ydHMuU2Vzc2lvblN0b3JhZ2VTdHJhdGVneSA9IHN0b3JhZ2VfMS5TZXNzaW9uU3RvcmFnZVN0cmF0ZWd5O1xudmFyIHVzZXJfMSA9IHJlcXVpcmUoJy4vdXNlci91c2VyJyk7XG5leHBvcnRzLlVzZXJDb250ZXh0ID0gdXNlcl8xLlVzZXJDb250ZXh0O1xuZXhwb3J0cy5Vc2VyID0gdXNlcl8xLlVzZXI7XG5leHBvcnRzLlNpbmdsZVVzZXJTZXJ2aWNlID0gdXNlcl8xLlNpbmdsZVVzZXJTZXJ2aWNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIFN0YXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXQoYXBwSWQsIHN0YXQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gMTsgfVxuICAgICAgICB0aGlzLmFwcElkID0gYXBwSWQ7XG4gICAgICAgIHRoaXMuc3RhdCA9IHN0YXQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5hcHBJZCA9IGFwcElkO1xuICAgICAgICB0aGlzLnN0YXQgPSBzdGF0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIFN0YXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcF9pZDogdGhpcy5hcHBJZCxcbiAgICAgICAgICAgIHN0YXQ6IHRoaXMuc3RhdCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgY3JlYXRlZDogdGhpcy5jcmVhdGVkLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdDtcbn0oKSk7XG5leHBvcnRzLlN0YXQgPSBTdGF0O1xuLyoqXG4gKiBBIGNsaWVudCBmb3IgSW5zaWdodHMgdGhhdCBoYW5kbGVzIGJhdGNoaW5nLCB1c2VyIGFjdGl2aXR5IGluc2lnaHQsIGFuZFxuICogc2VuZGluZyBpbnNpZ2h0cyBhdCBhbiBpbnRlcnZhbC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBJbnNpZ2h0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5zaWdodHMoZGVwcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAnaW50ZXJ2YWxTdWJtaXQnOiA2MCAqIDEwMDAsXG4gICAgICAgICAgICAnaW50ZXJ2YWxBY3RpdmVDaGVjayc6IDEwMDAsXG4gICAgICAgICAgICAnc3VibWl0Q291bnQnOiAxMDBcbiAgICAgICAgfTsgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmFwcCA9IGRlcHMuYXBwU3RhdHVzO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBkZXBzLnN0b3JhZ2U7XG4gICAgICAgIHRoaXMuY29uZmlnID0gZGVwcy5jb25maWc7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gZGVwcy5jbGllbnQ7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZGVwcy5sb2dnZXI7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBbXTtcbiAgICAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc3VibWl0KCk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbFN1Ym1pdCk7XG4gICAgICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuYXBwLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsQWN0aXZlQ2hlY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFjayBhbiBpbnNpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXQgLSBUaGUgaW5zaWdodCBuYW1lLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgYnkgd2hpY2ggdG8gaW5jcmVtZW50IHRoaXMgaW5zaWdodC5cbiAgICAgKi9cbiAgICBJbnNpZ2h0cy5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAoc3RhdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAxOyB9XG4gICAgICAgIHRoaXMudHJhY2tTdGF0KG5ldyBTdGF0KHRoaXMuY29uZmlnLmdldCgnYXBwX2lkJyksIHN0YXQsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBJbnNpZ2h0cy5wcm90b3R5cGUuY2hlY2tBY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnN0b3JhZ2UuZ2V0KCdpbnNpZ2h0c19zZXNzaW9uJyk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy5tYXJrQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHNlc3Npb24pO1xuICAgICAgICAgICAgdmFyIGhvdXIgPSA2MCAqIDYwICogMTAwMDtcbiAgICAgICAgICAgIGlmIChkLmdldFRpbWUoKSArIGhvdXIgPCBuZXcgRGF0ZSgpLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFya0FjdGl2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnNpZ2h0cy5wcm90b3R5cGUubWFya0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCgnaW5zaWdodHNfc2Vzc2lvbicsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMudHJhY2soJ21vYmlsZWFwcC5hY3RpdmUnKTtcbiAgICB9O1xuICAgIEluc2lnaHRzLnByb3RvdHlwZS50cmFja1N0YXQgPSBmdW5jdGlvbiAoc3RhdCkge1xuICAgICAgICB0aGlzLmJhdGNoLnB1c2goc3RhdCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFN1Ym1pdCgpKSB7XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnNpZ2h0cy5wcm90b3R5cGUuc2hvdWxkU3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaC5sZW5ndGggPj0gdGhpcy5vcHRpb25zLnN1Ym1pdENvdW50O1xuICAgIH07XG4gICAgSW5zaWdodHMucHJvdG90eXBlLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluc2lnaHRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmJhdGNoOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBfYVtfaV07XG4gICAgICAgICAgICBpbnNpZ2h0cy5wdXNoKHN0YXQudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50LnBvc3QoJy9pbnNpZ2h0cycpXG4gICAgICAgICAgICAuc2VuZCh7ICdpbnNpZ2h0cyc6IGluc2lnaHRzIH0pXG4gICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcignSW9uaWMgSW5zaWdodHM6IENvdWxkIG5vdCBzZW5kIGluc2lnaHRzLicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gSW5zaWdodHM7XG59KCkpO1xuZXhwb3J0cy5JbnNpZ2h0cyA9IEluc2lnaHRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFNpbXBsZSBjb25zb2xlIGxvZ2dlci5cbiAqL1xudmFyIExvZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiB0byB1c2UgdG8gbG9nIGluZm8gbGV2ZWwgbWVzc2FnZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZm9mbiA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdG8gdXNlIHRvIGxvZyB3YXJuIGxldmVsIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53YXJuZm4gPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiB0byB1c2UgdG8gbG9nIGVycm9yIGxldmVsIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lcnJvcmZuID0gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbG9nIGF0IGluZm8gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAbm90ZSBUT0RPOiBGaXggb3B0aW9uYWxQYXJhbXMgaW4gZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluZm9mbi5hcHBseSh0aGlzLCBbbWVzc2FnZV0uY29uY2F0KG9wdGlvbmFsUGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBsb2cgYXQgd2FybiBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBub3RlIFRPRE86IEZpeCBvcHRpb25hbFBhcmFtcyBpbiBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICovXG4gICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG9wdGlvbmFsUGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIHRoaXMud2FybmZuLmFwcGx5KHRoaXMsIFttZXNzYWdlXS5jb25jYXQob3B0aW9uYWxQYXJhbXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGxvZyBhdCBlcnJvciBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBub3RlIFRPRE86IEZpeCBvcHRpb25hbFBhcmFtcyBpbiBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsb2cuXG4gICAgICovXG4gICAgTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBvcHRpb25hbFBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvcmZuLmFwcGx5KHRoaXMsIFttZXNzYWdlXS5jb25jYXQob3B0aW9uYWxQYXJhbXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgRGVmZXJyZWRQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZlcnJlZFByb21pc2UoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBEZWZlcnJlZFByb21pc2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgX3RoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZlcnJlZFByb21pc2U7XG59KCkpO1xuZXhwb3J0cy5EZWZlcnJlZFByb21pc2UgPSBEZWZlcnJlZFByb21pc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhIHB1c2ggbm90aWZpY2F0aW9uIHNlbnQgdG8gdGhlIGRldmljZS5cbiAqXG4gKiBAZmVhdHVyZWRcbiAqL1xudmFyIFB1c2hNZXNzYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQdXNoTWVzc2FnZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUHVzaE1lc3NhZ2UgZnJvbSB0aGUgcHVzaCBwbHVnaW4ncyBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBwbHVnaW4ncyBub3RpZmljYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIFB1c2hNZXNzYWdlLmZyb21QbHVnaW5EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgUHVzaE1lc3NhZ2UoKTtcbiAgICAgICAgbWVzc2FnZS5yYXcgPSBkYXRhO1xuICAgICAgICBtZXNzYWdlLnRleHQgPSBkYXRhLm1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2UudGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgICAgICBtZXNzYWdlLmNvdW50ID0gZGF0YS5jb3VudDtcbiAgICAgICAgbWVzc2FnZS5zb3VuZCA9IGRhdGEuc291bmQ7XG4gICAgICAgIG1lc3NhZ2UuaW1hZ2UgPSBkYXRhLmltYWdlO1xuICAgICAgICBtZXNzYWdlLmFwcCA9IHtcbiAgICAgICAgICAgICdhc2xlZXAnOiAhZGF0YS5hZGRpdGlvbmFsRGF0YS5mb3JlZ3JvdW5kLFxuICAgICAgICAgICAgJ2Nsb3NlZCc6IGRhdGEuYWRkaXRpb25hbERhdGEuY29sZHN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IGRhdGEuYWRkaXRpb25hbERhdGFbJ3BheWxvYWQnXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbiAgICBQdXNoTWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIjxQdXNoTWVzc2FnZSBbXFxcIlwiICsgdGhpcy50aXRsZSArIFwiXFxcIl0+XCI7XG4gICAgfTtcbiAgICByZXR1cm4gUHVzaE1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5QdXNoTWVzc2FnZSA9IFB1c2hNZXNzYWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vcHJvbWlzZScpO1xudmFyIG1lc3NhZ2VfMSA9IHJlcXVpcmUoJy4vbWVzc2FnZScpO1xuLyoqXG4gKiBgUHVzaGAgaGFuZGxlcyBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIHRoaXMgYXBwLlxuICpcbiAqIEBmZWF0dXJlZFxuICovXG52YXIgUHVzaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVzaChkZXBzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1JlZ2lzdHJhdGlvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tVbnJlZ2lzdGVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1NhdmVUb2tlbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGRlcHMuY29uZmlnO1xuICAgICAgICB0aGlzLmF1dGggPSBkZXBzLmF1dGg7XG4gICAgICAgIHRoaXMudXNlclNlcnZpY2UgPSBkZXBzLnVzZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRldmljZSA9IGRlcHMuZGV2aWNlO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGRlcHMuY2xpZW50O1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBkZXBzLmVtaXR0ZXI7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IGRlcHMuc3RvcmFnZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBkZXBzLmxvZ2dlcjtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSByZXF1aXJlZCB2YWx1ZXMgdG8gdXNlIHRoaXMgc2VydmljZVxuICAgICAgICBpZiAodGhpcy5kZXZpY2UuaXNBbmRyb2lkKCkgJiYgIXRoaXMub3B0aW9ucy5zZW5kZXJfaWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdJb25pYyBQdXNoOiBHQ00gcHJvamVjdCBudW1iZXIgbm90IGZvdW5kIChodHRwOi8vZG9jcy5pb25pYy5pby9kb2NzL3B1c2gtYW5kcm9pZC1zZXR1cCknKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMucGx1Z2luQ29uZmlnKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBsdWdpbkNvbmZpZyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRldmljZS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGdjbSBrZXkgZm9yIFB1c2hQbHVnaW5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wbHVnaW5Db25maWcuYW5kcm9pZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGx1Z2luQ29uZmlnLmFuZHJvaWQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wbHVnaW5Db25maWcuYW5kcm9pZC5zZW5kZXJJRCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGx1Z2luQ29uZmlnLmFuZHJvaWQuc2VuZGVySUQgPSB0aGlzLm9wdGlvbnMuc2VuZGVyX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQdXNoLnByb3RvdHlwZSwgXCJ0b2tlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gdGhpcy5zdG9yYWdlLmdldCgncHVzaF90b2tlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbGV0ZSgncHVzaF90b2tlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldCgncHVzaF90b2tlbicsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSB0b2tlbiB3aXRoIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBXaGVuIGEgdG9rZW4gaXMgc2F2ZWQsIHlvdSBjYW4gc2VuZCBwdXNoIG5vdGlmaWNhdGlvbnMgdG8gaXQuIElmIGEgdXNlciBpc1xuICAgICAqIGxvZ2dlZCBpbiwgdGhlIHRva2VuIGlzIGxpbmtlZCB0byB0aGVtIGJ5IHRoZWlyIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIC0gVGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgUHVzaC5wcm90b3R5cGUuc2F2ZVRva2VuID0gZnVuY3Rpb24gKHRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIHZhciB0b2tlbkRhdGEgPSB7XG4gICAgICAgICAgICAndG9rZW4nOiB0b2tlbi50b2tlbixcbiAgICAgICAgICAgICdhcHBfaWQnOiB0aGlzLmNvbmZpZy5nZXQoJ2FwcF9pZCcpXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVfdXNlcikge1xuICAgICAgICAgICAgdmFyIHVzZXIgPSB0aGlzLnVzZXJTZXJ2aWNlLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dGguaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbkRhdGEudXNlcl9pZCA9IHVzZXIuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmJsb2NrU2F2ZVRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5wb3N0KCcvcHVzaC90b2tlbnMnKVxuICAgICAgICAgICAgICAgIC5zZW5kKHRva2VuRGF0YSlcbiAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmxvY2tTYXZlVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKCdJb25pYyBQdXNoOicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmxvY2tTYXZlVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2g6IHNhdmVkIHB1c2ggdG9rZW46ICcgKyB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbkRhdGEudXNlcl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2g6IGFkZGVkIHB1c2ggdG9rZW4gdG8gdXNlcjogJyArIHRva2VuRGF0YS51c2VyX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pZCA9IHJlcy5ib2R5LmRhdGEuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSByZXMuYm9keS5kYXRhLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnNhdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKCdBIHRva2VuIHNhdmUgb3BlcmF0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBkZXZpY2Ugd2l0aCBHQ00vQVBOUyB0byBnZXQgYSBwdXNoIHRva2VuLlxuICAgICAqXG4gICAgICogQWZ0ZXIgYSBkZXZpY2UgaXMgcmVnaXN0ZXJlZCwgeW91IHdpbGwgbGlrZWx5IHdhbnQgdG8gc2F2ZSB0aGUgdG9rZW4gd2l0aFxuICAgICAqIFtgc2F2ZVRva2VuKClgXSgvYXBpL2NsaWVudC9wdXNoLyNzYXZlVG9rZW4pIHRvIHRoZSBBUEkuXG4gICAgICovXG4gICAgUHVzaC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrUmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKCdBbm90aGVyIHJlZ2lzdHJhdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzLicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tSZWdpc3RyYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLm9uY2UoJ2RldmljZTpyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHVzaFBsdWdpbiA9IF90aGlzLl9nZXRQdXNoUGx1Z2luKCk7XG4gICAgICAgICAgICAgICAgaWYgKHB1c2hQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luID0gcHVzaFBsdWdpbi5pbml0KF90aGlzLm9wdGlvbnMucGx1Z2luQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luLm9uKCdyZWdpc3RyYXRpb24nLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmxvY2tSZWdpc3RyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRva2VuID0geyAndG9rZW4nOiBkYXRhLnJlZ2lzdHJhdGlvbklkIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2tlbi5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoX3RoaXMudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbGxiYWNrUmVnaXN0cmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcignUHVzaCBwbHVnaW4gbm90IGZvdW5kISBTZWUgbG9ncy4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIHRoZSBjdXJyZW50IHB1c2ggdG9rZW4uXG4gICAgICovXG4gICAgUHVzaC5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmJsb2NrVW5yZWdpc3Rlcikge1xuICAgICAgICAgICAgdmFyIHB1c2hUb2tlbl8xID0gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIGlmICghcHVzaFRva2VuXzEpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAndG9rZW4nOiBwdXNoVG9rZW5fMS50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgJ2FwcF9pZCc6IHRoaXMuY29uZmlnLmdldCgnYXBwX2lkJylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi51bnJlZ2lzdGVyKGZ1bmN0aW9uICgpIHsgfSwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQucG9zdCgnL3B1c2gvdG9rZW5zL2ludmFsaWRhdGUnKVxuICAgICAgICAgICAgICAgICAgICAuc2VuZCh0b2tlbkRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJsb2NrVW5yZWdpc3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoJ0lvbmljIFB1c2g6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2g6IHVucmVnaXN0ZXJlZCBwdXNoIHRva2VuOiAnICsgcHVzaFRva2VuXzEudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKCdBbiB1bnJlZ2lzdGVyIG9wZXJhdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzLicpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsb2NrVW5yZWdpc3RlciA9IHRydWU7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5fY2FsbGJhY2tSZWdpc3RyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGx1Z2luLm9uKCdyZWdpc3RyYXRpb24nLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMudG9rZW4gPSB7ICd0b2tlbic6IGRhdGEucmVnaXN0cmF0aW9uSWQgfTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oJ0lvbmljIFB1c2ggKGRlYnVnKTogZGV2aWNlIHRva2VuIHJlZ2lzdGVyZWQ6ICcgKyBfdGhpcy50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoJ3B1c2g6cmVnaXN0ZXInLCBfdGhpcy50b2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsdWdpbi5vbignbm90aWZpY2F0aW9uJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZV8xLlB1c2hNZXNzYWdlLmZyb21QbHVnaW5EYXRhKGRhdGEpO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuaW5mbygnSW9uaWMgUHVzaCAoZGVidWcpOiBub3RpZmljYXRpb24gcmVjZWl2ZWQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIuZW1pdCgncHVzaDpub3RpZmljYXRpb24nLCB7ICdtZXNzYWdlJzogbWVzc2FnZSwgJ3Jhdyc6IGRhdGEgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsdWdpbi5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoJ0lvbmljIFB1c2ggKGRlYnVnKTogdW5leHBlY3RlZCBlcnJvciBvY2N1cmVkLicpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcignSW9uaWMgUHVzaDonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIuZW1pdCgncHVzaDplcnJvcicsIHsgJ2Vycic6IGUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQdXNoLnByb3RvdHlwZS5fZ2V0UHVzaFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBsdWdpbiA9IHdpbmRvdy5QdXNoTm90aWZpY2F0aW9uO1xuICAgICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGV2aWNlLmlzSU9TKCkgfHwgdGhpcy5kZXZpY2UuaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignSW9uaWMgUHVzaDogUHVzaE5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgcmVxdWlyZWQuIEhhdmUgeW91IHJ1biBgaW9uaWMgcGx1Z2luIGFkZCBwaG9uZWdhcC1wbHVnaW4tcHVzaGAgPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignSW9uaWMgUHVzaDogRGlzYWJsZWQhIE5hdGl2ZSBwdXNoIG5vdGlmaWNhdGlvbnMgd2lsbCBub3Qgd29yayBpbiBhIGJyb3dzZXIuIFJ1biB5b3VyIGFwcCBvbiBhbiBhY3R1YWwgZGV2aWNlIHRvIHVzZSBwdXNoLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgfTtcbiAgICByZXR1cm4gUHVzaDtcbn0oKSk7XG5leHBvcnRzLlB1c2ggPSBQdXNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIExvY2FsU3RvcmFnZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhbFN0b3JhZ2VTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgTG9jYWxTdG9yYWdlU3RyYXRlZ3kucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfTtcbiAgICBMb2NhbFN0b3JhZ2VTdHJhdGVneS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgTG9jYWxTdG9yYWdlU3RyYXRlZ3kucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxTdG9yYWdlU3RyYXRlZ3k7XG59KCkpO1xuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VTdHJhdGVneSA9IExvY2FsU3RvcmFnZVN0cmF0ZWd5O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBTZXNzaW9uU3RvcmFnZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXNzaW9uU3RvcmFnZVN0cmF0ZWd5KCkge1xuICAgIH1cbiAgICBTZXNzaW9uU3RvcmFnZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfTtcbiAgICBTZXNzaW9uU3RvcmFnZVN0cmF0ZWd5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIFNlc3Npb25TdG9yYWdlU3RyYXRlZ3kucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9O1xuICAgIHJldHVybiBTZXNzaW9uU3RvcmFnZVN0cmF0ZWd5O1xufSgpKTtcbmV4cG9ydHMuU2Vzc2lvblN0b3JhZ2VTdHJhdGVneSA9IFNlc3Npb25TdG9yYWdlU3RyYXRlZ3k7XG4vKipcbiAqIEEgZ2VuZXJpYyBsb2NhbC9zZXNzaW9uIHN0b3JhZ2UgYWJzdHJhY3Rpb24uXG4gKi9cbnZhciBTdG9yYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yYWdlKGRlcHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyAncHJlZml4JzogJ2lvbmljJywgJ2NhY2hlJzogdHJ1ZSB9OyB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBkZXBzLnN0cmF0ZWd5O1xuICAgICAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYSB2YWx1ZSBpbiB0aGUgc3RvcmFnZSBieSB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBzdG9yYWdlIGtleSB0byBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC4gKE11c3QgYmUgSlNPTi1zZXJpYWxpemFibGUpLlxuICAgICAqL1xuICAgIFN0b3JhZ2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSA9IHRoaXMuc3RhbmRhcmRpemVLZXkoa2V5KTtcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kuc2V0KGtleSwganNvbik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUNhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdmFsdWUgZnJvbSB0aGUgc3RvcmFnZSBieSB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBzdG9yYWdlIGtleSB0byBkZWxldGUuXG4gICAgICovXG4gICAgU3RvcmFnZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBrZXkgPSB0aGlzLnN0YW5kYXJkaXplS2V5KGtleSk7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kuZGVsZXRlKGtleSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2VDYWNoZVtrZXldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWx1ZSBmcm9tIHRoZSBzdG9yYWdlIGJ5IHRoZSBnaXZlbiBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIHN0b3JhZ2Uga2V5IHRvIGdldC5cbiAgICAgKi9cbiAgICBTdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGtleSA9IHRoaXMuc3RhbmRhcmRpemVLZXkoa2V5KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuc3RvcmFnZUNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIganNvbiA9IHRoaXMuc3RyYXRlZ3kuZ2V0KGtleSk7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlQ2FjaGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN0b3JhZ2UucHJvdG90eXBlLnN0YW5kYXJkaXplS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByZWZpeCArIFwiX1wiICsga2V5O1xuICAgIH07XG4gICAgcmV0dXJuIFN0b3JhZ2U7XG59KCkpO1xuZXhwb3J0cy5TdG9yYWdlID0gU3RvcmFnZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRhdGFUeXBlTWFwcGluZyA9IHt9O1xudmFyIERhdGFUeXBlU2NoZW1hID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRhVHlwZVNjaGVtYShwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgfVxuICAgIERhdGFUeXBlU2NoZW1hLnByb3RvdHlwZS5zZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVt4XSA9IHByb3BlcnRpZXNbeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGFUeXBlU2NoZW1hLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ19fSW9uaWNfRGF0YVR5cGVTY2hlbWEnOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICAndmFsdWUnOiBkYXRhLnZhbHVlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYXRhVHlwZVNjaGVtYS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5uYW1lICYmIHRoaXMuZGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFUeXBlU2NoZW1hO1xufSgpKTtcbmV4cG9ydHMuRGF0YVR5cGVTY2hlbWEgPSBEYXRhVHlwZVNjaGVtYTtcbnZhciBEYXRhVHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YVR5cGUoKSB7XG4gICAgfVxuICAgIERhdGFUeXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZGF0YVR5cGVNYXBwaW5nW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRhdGFUeXBlTWFwcGluZ1tuYW1lXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRGF0YVR5cGUuZ2V0TWFwcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFUeXBlTWFwcGluZztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhVHlwZSwgXCJTY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRhVHlwZVNjaGVtYTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGF0YVR5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSwgY2xzKSB7XG4gICAgICAgIGRhdGFUeXBlTWFwcGluZ1tuYW1lXSA9IGNscztcbiAgICB9O1xuICAgIHJldHVybiBEYXRhVHlwZTtcbn0oKSk7XG5leHBvcnRzLkRhdGFUeXBlID0gRGF0YVR5cGU7XG52YXIgVW5pcXVlQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuaXF1ZUFycmF5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaCh2YWx1ZVt4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVW5pcXVlQXJyYXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBzY2hlbWEgPSBuZXcgRGF0YVR5cGVTY2hlbWEoeyAnbmFtZSc6ICdVbmlxdWVBcnJheScsICd2YWx1ZSc6IGRhdGEgfSk7XG4gICAgICAgIHJldHVybiBzY2hlbWEudG9KU09OKCk7XG4gICAgfTtcbiAgICBVbmlxdWVBcnJheS5mcm9tU3RvcmFnZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFVuaXF1ZUFycmF5KHZhbHVlKTtcbiAgICB9O1xuICAgIFVuaXF1ZUFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVuaXF1ZUFycmF5LnByb3RvdHlwZS5wdWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGF0YS5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5pcXVlQXJyYXk7XG59KCkpO1xuZXhwb3J0cy5VbmlxdWVBcnJheSA9IFVuaXF1ZUFycmF5O1xuRGF0YVR5cGUucmVnaXN0ZXIoJ1VuaXF1ZUFycmF5JywgVW5pcXVlQXJyYXkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vcHJvbWlzZScpO1xudmFyIGRhdGFfdHlwZXNfMSA9IHJlcXVpcmUoJy4vZGF0YS10eXBlcycpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBVc2VyQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXNlckNvbnRleHQoZGVwcykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGRlcHMuY29uZmlnO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBkZXBzLnN0b3JhZ2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQ29udGV4dC5wcm90b3R5cGUsIFwibGFiZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndXNlcl8nICsgdGhpcy5jb25maWcuZ2V0KCdhcHBfaWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVXNlckNvbnRleHQucHJvdG90eXBlLnVuc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5kZWxldGUodGhpcy5sYWJlbCk7XG4gICAgfTtcbiAgICBVc2VyQ29udGV4dC5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KHRoaXMubGFiZWwsIHVzZXIuc2VyaWFsaXplRm9yU3RvcmFnZSgpKTtcbiAgICB9O1xuICAgIFVzZXJDb250ZXh0LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnN0b3JhZ2UuZ2V0KHRoaXMubGFiZWwpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdXNlci5pZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgICB1c2VyLmRhdGEgPSBuZXcgVXNlckRhdGEoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIHVzZXIuZGV0YWlscyA9IGRhdGEuZGV0YWlscyB8fCB7fTtcbiAgICAgICAgICAgIHVzZXIuc29jaWFsID0gZGF0YS5zb2NpYWwgfHwge307XG4gICAgICAgICAgICB1c2VyLmZyZXNoID0gZGF0YS5mcmVzaDtcbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIHJldHVybiBVc2VyQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLlVzZXJDb250ZXh0ID0gVXNlckNvbnRleHQ7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xudmFyIFVzZXJEYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVc2VyRGF0YShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICBpZiAoKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLmRlc2VyaWFsaXplRGF0YVR5cGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVXNlckRhdGEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IDAgfHwgZGVmYXVsdFZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVzZXJEYXRhLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgVXNlckRhdGEucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFVzZXJEYXRhLnByb3RvdHlwZS5kZXNlcmlhbGl6ZURhdGFUeXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeCBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFuIG9iamVjdCwgbGV0J3MgY2hlY2sgZm9yIGN1c3RvbSBkYXRhIHR5cGVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YVt4XSAmJiB0eXBlb2YgdGhpcy5kYXRhW3hdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyB3ZSBoYXZlIGEgY3VzdG9tIHR5cGU/XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbeF0uX19Jb25pY19EYXRhVHlwZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmRhdGFbeF0uX19Jb25pY19EYXRhVHlwZVNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0gZGF0YV90eXBlc18xLkRhdGFUeXBlLmdldE1hcHBpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIGN1c3RvbSB0eXBlIGFuZCBhIHJlZ2lzdGVyZWQgY2xhc3MsIGdpdmUgdGhlIGN1c3RvbSBkYXRhIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbeF0gPSBtYXBwaW5nW25hbWVdLmZyb21TdG9yYWdlKHRoaXMuZGF0YVt4XS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBVc2VyRGF0YTtcbn0oKSk7XG5leHBvcnRzLlVzZXJEYXRhID0gVXNlckRhdGE7XG4vKipcbiAqIFJlcHJlc2VudHMgYSB1c2VyIG9mIHRoZSBhcHAuXG4gKlxuICogQGZlYXR1cmVkXG4gKi9cbnZhciBVc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVc2VyKGRlcHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZXRhaWxzIChlbWFpbCwgcGFzc3dvcmQsIGV0Yykgb2YgdGhpcyB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXRhaWxzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc29jaWFsIGRldGFpbHMgb2YgdGhpcyB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb2NpYWwgPSB7fTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gZGVwcy5zZXJ2aWNlO1xuICAgICAgICB0aGlzLmZyZXNoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdW5zZXQgPSB7fTtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVzZXJEYXRhKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhpcyB1c2VyIGlzIGFub255bW91cyBvciBub3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYGlkYCBwcm9wZXJ0eSBpcyBzZXQsIHRoZSB1c2VyIGlzIG5vIGxvbmdlciBhbm9ueW1vdXMuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuaXNBbm9ueW1vdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBhIHZhbHVlIGZyb20gdGhpcyB1c2VyJ3MgY3VzdG9tIGRhdGEuXG4gICAgICpcbiAgICAgKiBPcHRpb25hbGx5LCBhIGRlZmF1bHQgdmFsdWUgY2FuIGJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBkYXRhIGtleSB0byBnZXQuXG4gICAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIGtleSBpcyBhYnNlbnQuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIHZhbHVlIGluIHRoaXMgdXNlcidzIGN1c3RvbSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBkYXRhIGtleSB0byBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5zZXRba2V5XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB2YWx1ZSBmcm9tIHRoaXMgdXNlcidzIGN1c3RvbSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBkYXRhIGtleSB0byBkZWxldGUuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuX3Vuc2V0W2tleV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnVuc2V0KGtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXZlcnQgdGhpcyB1c2VyIHRvIGEgZnJlc2gsIGFub255bW91cyBzdGF0ZS5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVc2VyRGF0YSgpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSB7fTtcbiAgICAgICAgdGhpcy5mcmVzaCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlIHRoaXMgdXNlciB0byB0aGUgQVBJLlxuICAgICAqL1xuICAgIFVzZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Vuc2V0ID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2Uuc2F2ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoaXMgdXNlciBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmRlbGV0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgdXNlciBmcm9tIHRoZSBBUEksIG92ZXJ3cml0aW5nIHRoZSBsb2NhbCB1c2VyJ3MgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSB1c2VyIElEIHRvIGxvYWQgaW50byB0aGlzIHVzZXIuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmxvYWQoaWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcmUgdGhpcyB1c2VyIGluIGxvY2FsIHN0b3JhZ2UuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VydmljZS5zdG9yZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoaXMgdXNlciBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUudW5zdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnVuc3RvcmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBVc2VyLnByb3RvdHlwZS5zZXJpYWxpemVGb3JBUEkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZW1haWwnOiB0aGlzLmRldGFpbHMuZW1haWwsXG4gICAgICAgICAgICAncGFzc3dvcmQnOiB0aGlzLmRldGFpbHMucGFzc3dvcmQsXG4gICAgICAgICAgICAndXNlcm5hbWUnOiB0aGlzLmRldGFpbHMudXNlcm5hbWUsXG4gICAgICAgICAgICAnaW1hZ2UnOiB0aGlzLmRldGFpbHMuaW1hZ2UsXG4gICAgICAgICAgICAnbmFtZSc6IHRoaXMuZGV0YWlscy5uYW1lLFxuICAgICAgICAgICAgJ2N1c3RvbSc6IHRoaXMuZGF0YS5kYXRhXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgVXNlci5wcm90b3R5cGUuc2VyaWFsaXplRm9yU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMuaWQsXG4gICAgICAgICAgICAnZGF0YSc6IHRoaXMuZGF0YS5kYXRhLFxuICAgICAgICAgICAgJ2RldGFpbHMnOiB0aGlzLmRldGFpbHMsXG4gICAgICAgICAgICAnZnJlc2gnOiB0aGlzLmZyZXNoLFxuICAgICAgICAgICAgJ3NvY2lhbCc6IHRoaXMuc29jaWFsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBVc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiPFVzZXIgW1wiICsgKHRoaXMuaXNBbm9ueW1vdXMoKSA/ICdhbm9ueW1vdXMnIDogdGhpcy5pZCkgKyBcIl0+XCI7XG4gICAgfTtcbiAgICByZXR1cm4gVXNlcjtcbn0oKSk7XG5leHBvcnRzLlVzZXIgPSBVc2VyO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBTaW5nbGVVc2VyU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2luZ2xlVXNlclNlcnZpY2UoZGVwcywgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5jbGllbnQgPSBkZXBzLmNsaWVudDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gZGVwcy5jb250ZXh0O1xuICAgIH1cbiAgICBTaW5nbGVVc2VyU2VydmljZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXNlciA9IHRoaXMuY29udGV4dC5sb2FkKG5ldyBVc2VyKHsgJ3NlcnZpY2UnOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudXNlcikge1xuICAgICAgICAgICAgdGhpcy51c2VyID0gbmV3IFVzZXIoeyAnc2VydmljZSc6IHRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXNlcjtcbiAgICB9O1xuICAgIFNpbmdsZVVzZXJTZXJ2aWNlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3JlKHRoaXMuY3VycmVudCgpKTtcbiAgICB9O1xuICAgIFNpbmdsZVVzZXJTZXJ2aWNlLnByb3RvdHlwZS51bnN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQudW5zdG9yZSgpO1xuICAgIH07XG4gICAgU2luZ2xlVXNlclNlcnZpY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSAnc2VsZic7IH1cbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgdmFyIHVzZXIgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgdGhpcy5jbGllbnQuZ2V0KFwiL3VzZXJzL1wiICsgaWQpXG4gICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXNlci5pZCA9IHJlcy5ib2R5LmRhdGEudXVpZDtcbiAgICAgICAgICAgICAgICB1c2VyLmRhdGEgPSBuZXcgVXNlckRhdGEocmVzLmJvZHkuZGF0YS5jdXN0b20pO1xuICAgICAgICAgICAgICAgIHVzZXIuZGV0YWlscyA9IHJlcy5ib2R5LmRhdGEuZGV0YWlscztcbiAgICAgICAgICAgICAgICB1c2VyLmZyZXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXNlci5zb2NpYWwgPSByZXMuYm9keS5kYXRhLnNvY2lhbDtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIFNpbmdsZVVzZXJTZXJ2aWNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBwcm9taXNlXzEuRGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGlmICh0aGlzLnVzZXIuaXNBbm9ueW1vdXMoKSkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcignVXNlciBpcyBhbm9ueW1vdXMgYW5kIGNhbm5vdCBiZSBkZWxldGVkIGZyb20gdGhlIEFQSS4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVuc3RvcmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmRlbGV0ZShcIi91c2Vycy9cIiArIHRoaXMudXNlci5pZClcbiAgICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICBTaW5nbGVVc2VyU2VydmljZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHByb21pc2VfMS5EZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgdGhpcy5zdG9yZSgpO1xuICAgICAgICBpZiAodGhpcy51c2VyLmlzQW5vbnltb3VzKCkpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoJ1VzZXIgaXMgYW5vbnltb3VzIGFuZCBjYW5ub3QgYmUgdXBkYXRlZCBpbiB0aGUgQVBJLiBVc2UgbG9hZCg8aWQ+KSBvciBzaWdudXAgYSB1c2VyIHVzaW5nIGF1dGguJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQucGF0Y2goXCIvdXNlcnMvXCIgKyB0aGlzLnVzZXIuaWQpXG4gICAgICAgICAgICAgICAgLnNlbmQodGhpcy51c2VyLnNlcmlhbGl6ZUZvckFQSSgpKVxuICAgICAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVzZXIuZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZVVzZXJTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuU2luZ2xlVXNlclNlcnZpY2UgPSBTaW5nbGVVc2VyU2VydmljZTtcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIlxuLyoqXG4gKiBSZWR1Y2UgYGFycmAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxcbiAqXG4gKiBUT0RPOiBjb21iYXRpYmxlIGVycm9yIGhhbmRsaW5nP1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCl7ICBcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgY3VyciA9IGFyZ3VtZW50cy5sZW5ndGggPT0gM1xuICAgID8gaW5pdGlhbFxuICAgIDogYXJyW2lkeCsrXTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgY3VyciA9IGZuLmNhbGwobnVsbCwgY3VyciwgYXJyW2lkeF0sICsraWR4LCBhcnIpO1xuICB9XG4gIFxuICByZXR1cm4gY3Vycjtcbn07IiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlcicpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJ3JlZHVjZScpO1xudmFyIHJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxudmFyIHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgcm9vdCA9IHRoaXM7XG59XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBUT0RPOiBmdXR1cmUgcHJvb2YsIG1vdmUgdG8gY29tcG9lbnQgbGFuZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0hvc3Qob2JqKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEZvcm1EYXRhXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG52YXIgcmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZXF1ZXN0JykuYmluZChudWxsLCBSZXF1ZXN0KTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gZnVuY3Rpb24gKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdFxuICAgICAgJiYgKCFyb290LmxvY2F0aW9uIHx8ICdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbFxuICAgICAgICAgIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgfSBlbHNlIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAobnVsbCAhPSBvYmpba2V5XSkge1xuICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogSGVscHMgJ3NlcmlhbGl6ZScgd2l0aCBzZXJpYWxpemluZyBhcnJheXMuXG4gKiBNdXRhdGVzIHRoZSBwYWlycyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKi9cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgfSk7XG4gIH1cbiAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbiAvKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYXJ0cztcbiAgdmFyIHBhaXI7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBhcnRzID0gcGFpci5zcGxpdCgnPScpO1xuICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFydHNbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbiByZXF1ZXN0LnNlcmlhbGl6ZSA9IHtcbiAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG4gfTtcblxuIC8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgZmllbGRzID0ge307XG4gIHZhciBpbmRleDtcbiAgdmFyIGxpbmU7XG4gIHZhciBmaWVsZDtcbiAgdmFyIHZhbDtcblxuICBsaW5lcy5wb3AoKTsgLy8gdHJhaWxpbmcgQ1JMRlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG1pbWVgIGlzIGpzb24gb3IgaGFzICtqc29uIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzSlNPTihtaW1lKSB7XG4gIHJldHVybiAvW1xcLytdanNvblxcYi8udGVzdChtaW1lKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHR5cGUoc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyYW1zKHN0cil7XG4gIHJldHVybiByZWR1Y2Uoc3RyLnNwbGl0KC8gKjsgKi8pLCBmdW5jdGlvbihvYmosIHN0cil7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKj0gKi8pXG4gICAgICAsIGtleSA9IHBhcnRzLnNoaWZ0KClcbiAgICAgICwgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICAgIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMucmVxID0gcmVxO1xuICB0aGlzLnhociA9IHRoaXMucmVxLnhocjtcbiAgLy8gcmVzcG9uc2VUZXh0IGlzIGFjY2Vzc2libGUgb25seSBpZiByZXNwb25zZVR5cGUgaXMgJycgb3IgJ3RleHQnIGFuZCBvbiBvbGRlciBicm93c2Vyc1xuICB0aGlzLnRleHQgPSAoKHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyAmJiAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8IHR5cGVvZiB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKVxuICAgICA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dFxuICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB0aGlzLnNldFN0YXR1c1Byb3BlcnRpZXModGhpcy54aHIuc3RhdHVzKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLnNldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpO1xuICB0aGlzLmJvZHkgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnXG4gICAgPyB0aGlzLnBhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSlcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgLy8gY29udGVudC10eXBlXG4gIHZhciBjdCA9IHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgdGhpcy50eXBlID0gdHlwZShjdCk7XG5cbiAgLy8gcGFyYW1zXG4gIHZhciBvYmogPSBwYXJhbXMoY3QpO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB0aGlzW2tleV0gPSBvYmpba2V5XTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUucGFyc2VCb2R5ID0gZnVuY3Rpb24oc3RyKXtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuXG4gIHZhciB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAvLyBzdGF0dXMgLyBjbGFzc1xuICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAvLyBiYXNpY3NcbiAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgIDogZmFsc2U7XG5cbiAgLy8gc3VnYXJcbiAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgdGhpcy5iYWRSZXF1ZXN0ID0gNDAwID09IHN0YXR1cztcbiAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gc2VsZi54aHIgJiYgc2VsZi54aHIucmVzcG9uc2VUZXh0ID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogbnVsbDtcbiAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnN0YXR1c0NvZGUgPSBzZWxmLnhociAmJiBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMCkge1xuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyLCByZXMpO1xuICAgIH1cblxuICAgIHZhciBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgIG5ld19lcnIub3JpZ2luYWwgPSBlcnI7XG4gICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG5cbiAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYHJlcXVlc3RCYXNlYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcbmZvciAodmFyIGtleSBpbiByZXF1ZXN0QmFzZSkge1xuICBSZXF1ZXN0LnByb3RvdHlwZVtrZXldID0gcmVxdWVzdEJhc2Vba2V5XTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuO1xuICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgcmVzcG9uc2VUeXBlIHRvIGB2YWxgLiBQcmVzZW50bHkgdmFsaWQgcmVzcG9uc2VUeXBlcyBhcmUgJ2Jsb2InIGFuZCBcbiAqICdhcnJheWJ1ZmZlcicuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24odmFsKXtcbiAgdGhpcy5fcmVzcG9uc2VUeXBlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEF1dGhvcml6YXRpb24gZmllbGQgdmFsdWUgd2l0aCBgdXNlcmAgYW5kIGBwYXNzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGggJ3R5cGUnIHByb3BlcnR5ICdhdXRvJyBvciAnYmFzaWMnIChkZWZhdWx0ICdiYXNpYycpXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMpe1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdHlwZTogJ2Jhc2ljJ1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdmFyIHN0ciA9IGJ0b2EodXNlciArICc6JyArIHBhc3MpO1xuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIHN0cik7XG4gICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbipcbiogRXhhbXBsZXM6XG4qXG4qICAgcmVxdWVzdC5nZXQoJy9zaG9lcycpXG4qICAgICAucXVlcnkoJ3NpemU9MTAnKVxuKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxuKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiogQGFwaSBwdWJsaWNcbiovXG5cblJlcXVlc3QucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24odmFsKXtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB2YWwpIHZhbCA9IHNlcmlhbGl6ZSh2YWwpO1xuICBpZiAodmFsKSB0aGlzLl9xdWVyeS5wdXNoKHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxuICogd2l0aCBvcHRpb25hbCBgZmlsZW5hbWVgLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaChuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgZmlsZW5hbWUpe1xuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgZmlsZW5hbWUgfHwgZmlsZS5uYW1lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIG9iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKG9iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghb2JqIHx8IGlzSG9zdChkYXRhKSkgcmV0dXJuIHRoaXM7XG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5SZXNwb25zZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pe1xuICBpZiAocm9vdC5jb25zb2xlKSB7XG4gICAgY29uc29sZS53YXJuKFwiQ2xpZW50LXNpZGUgcGFyc2UoKSBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBzZXJpYWxpemUoKS4gVGhpcyBtZXRob2QgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBzdXBlcmFnZW50IHYyLjBcIik7XG4gIH1cbiAgdGhpcy5zZXJpYWxpemUoZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgZm4oZXJyLCByZXMpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcm9zc0RvbWFpbkVycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnRpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9IHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKTtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gc3RhdGUgY2hhbmdlXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkgeyBzdGF0dXMgPSB4aHIuc3RhdHVzIH0gY2F0Y2goZSkgeyBzdGF0dXMgPSAwOyB9XG5cbiAgICBpZiAoMCA9PSBzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0KSByZXR1cm4gc2VsZi50aW1lb3V0RXJyb3IoKTtcbiAgICAgIGlmIChzZWxmLmFib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICB2YXIgaGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbihlKXtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcbiAgICB9XG4gICAgZS5kaXJlY3Rpb24gPSAnZG93bmxvYWQnO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcztcbiAgfVxuICB0cnkge1xuICAgIGlmICh4aHIudXBsb2FkICYmIHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODM3MjQ1L3htbGh0dHByZXF1ZXN0LXVwbG9hZC10aHJvd3MtaW52YWxpZC1hcmd1bWVudC13aGVuLXVzZWQtZnJvbS13ZWItd29ya2VyLWNvbnRleHRcbiAgfVxuXG4gIC8vIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgICAgIHNlbGYuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfVxuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIGlmIChxdWVyeSkge1xuICAgIHF1ZXJ5ID0gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QocXVlcnkpO1xuICAgIHRoaXMudXJsICs9IH50aGlzLnVybC5pbmRleE9mKCc/JylcbiAgICAgID8gJyYnICsgcXVlcnlcbiAgICAgIDogJz8nICsgcXVlcnk7XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICB9IGVsc2Uge1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhaXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fcGFyc2VyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIGlmIChzZXJpYWxpemUpIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gIH1cblxuICAvLyBzZXQgaGVhZGVyIGZpZWxkc1xuICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmIChudWxsID09IHRoaXMuaGVhZGVyW2ZpZWxkXSkgY29udGludWU7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RgLlxuICovXG5cbnJlcXVlc3QuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gZGF0YSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVsKHVybCwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbnJlcXVlc3RbJ2RlbCddID0gZGVsO1xucmVxdWVzdFsnZGVsZXRlJ10gPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4iLCIvKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9IG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIHRoaXMuX3RpbWVvdXQgPSAwO1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRm9yY2UgZ2l2ZW4gcGFyc2VyXG4gKlxuICogU2V0cyB0aGUgYm9keSBwYXJzZXIgbm8gbWF0dGVyIHR5cGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGltZW91dCB0byBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQobXMpe1xuICB0aGlzLl90aW1lb3V0ID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGYXV4IHByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdFxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqL1xuXG5leHBvcnRzLnRoZW4gPSBmdW5jdGlvbiB0aGVuKGZ1bGZpbGwsIHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5lbmQoZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICBlcnIgPyByZWplY3QoZXJyKSA6IGZ1bGZpbGwocmVzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuZXhwb3J0cy5nZXRIZWFkZXIgPSBleHBvcnRzLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5leHBvcnRzLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAgZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiXG4gKiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiLy8gVGhlIG5vZGUgYW5kIGJyb3dzZXIgbW9kdWxlcyBleHBvc2UgdmVyc2lvbnMgb2YgdGhpcyB3aXRoIHRoZVxuLy8gYXBwcm9wcmlhdGUgY29uc3RydWN0b3IgZnVuY3Rpb24gYm91bmQgYXMgZmlyc3QgYXJndW1lbnRcbi8qKlxuICogSXNzdWUgYSByZXF1ZXN0OlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgIHJlcXVlc3QoJ0dFVCcsICcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnLCBjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdXJsIG9yIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZXF1ZXN0KFJlcXVlc3RDb25zdHJ1Y3RvciwgbWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdENvbnN0cnVjdG9yKCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgyID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVxdWVzdENvbnN0cnVjdG9yKG1ldGhvZCwgdXJsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0O1xuIiwiLy8gQW5ndWxhciAxIG1vZHVsZXMgYW5kIGZhY3RvcmllcyBmb3IgdGhlIGJ1bmRsZVxuXG5pZiAodHlwZW9mIGFuZ3VsYXIgPT09ICdvYmplY3QnICYmIGFuZ3VsYXIubW9kdWxlKSB7XG5cbiAgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICBJb25pYy5jb3JlLmluaXQoKTtcbiAgICBJb25pYy5jb3Jkb3ZhLmJvb3RzdHJhcCgpO1xuICB9KTtcblxuICBhbmd1bGFyLm1vZHVsZSgnaW9uaWMuY2xvdWQnLCBbXSlcblxuICAucHJvdmlkZXIoJyRpb25pY0Nsb3VkQ29uZmlnJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbmZpZyA9IElvbmljLmNvbmZpZztcblxuICAgIHRoaXMucmVnaXN0ZXIgPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgICAgY29uZmlnLnJlZ2lzdGVyKHNldHRpbmdzKTtcbiAgICB9O1xuXG4gICAgdGhpcy4kZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gIH0pXG5cbiAgLnByb3ZpZGVyKCckaW9uaWNDbG91ZCcsIFsnJGlvbmljQ2xvdWRDb25maWdQcm92aWRlcicsIGZ1bmN0aW9uKCRpb25pY0Nsb3VkQ29uZmlnUHJvdmlkZXIpIHtcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgJGlvbmljQ2xvdWRDb25maWdQcm92aWRlci5yZWdpc3Rlcih2YWx1ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuJGdldCA9IFtmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJb25pYy5jb3JlO1xuICAgIH1dO1xuICB9XSlcblxuICAuZmFjdG9yeSgnJGlvbmljRXZlbnRFbWl0dGVyJywgWyckcm9vdFNjb3BlJywgZnVuY3Rpb24oJHJvb3RTY29wZSkge1xuICAgIHZhciBlbWl0ID0gSW9uaWMuQ2xvdWQuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4gICAgSW9uaWMuQ2xvdWQuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG91ZDonICsgbmFtZSwgZGF0YSk7XG4gICAgICByZXR1cm4gZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW9uaWMuZXZlbnRFbWl0dGVyO1xuICB9XSlcblxuICAuZmFjdG9yeSgnJGlvbmljQ2xvdWRDbGllbnQnLCBbZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIElvbmljLmNsaWVudDtcbiAgfV0pXG5cbiAgLmZhY3RvcnkoJyRpb25pY1VzZXInLCBbZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIElvbmljLnNpbmdsZVVzZXJTZXJ2aWNlLmN1cnJlbnQoKTtcbiAgfV0pXG5cbiAgLmZhY3RvcnkoJyRpb25pY0F1dGgnLCBbZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIElvbmljLmF1dGg7XG4gIH1dKVxuXG4gIC5mYWN0b3J5KCckaW9uaWNQdXNoJywgW2Z1bmN0aW9uKCkge1xuICAgIHJldHVybiBJb25pYy5wdXNoO1xuICB9XSlcblxuICAuZmFjdG9yeSgnJGlvbmljRGVwbG95JywgW2Z1bmN0aW9uKCkge1xuICAgIHJldHVybiBJb25pYy5kZXBsb3k7XG4gIH1dKVxuXG4gIC5ydW4oWyckd2luZG93JywgJyRxJywgZnVuY3Rpb24oJHdpbmRvdywgJHEpIHtcbiAgICBpZiAodHlwZW9mICR3aW5kb3cuUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICR3aW5kb3cuUHJvbWlzZSA9ICRxO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5pdCA9IElvbmljLkNsb3VkLkRlZmVycmVkUHJvbWlzZS5wcm90b3R5cGUuaW5pdDtcblxuICAgICAgSW9uaWMuQ2xvdWQuRGVmZXJyZWRQcm9taXNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gJHEud2hlbih0aGlzLnByb21pc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxufVxuIiwidmFyIENvcmUgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9jb3JlXCIpLkNvcmU7XG52YXIgRGF0YVR5cGUgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS91c2VyL2RhdGEtdHlwZXNcIikuRGF0YVR5cGU7XG52YXIgRGVwbG95ID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvZGVwbG95L2RlcGxveVwiKS5EZXBsb3k7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvZXZlbnRzXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBMb2dnZXIgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9sb2dnZXJcIikuTG9nZ2VyO1xudmFyIFB1c2ggPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9wdXNoL3B1c2hcIikuUHVzaDtcbnZhciBQdXNoTWVzc2FnZSA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L3B1c2gvbWVzc2FnZVwiKS5QdXNoTWVzc2FnZTtcbnZhciBhdXRoID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvYXV0aFwiKTtcbnZhciBjbGllbnQgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9jbGllbnRcIik7XG52YXIgY29uZmlnID0gcmVxdWlyZShcIi4vLi4vZGlzdC9lczUvY29uZmlnXCIpO1xudmFyIGNvcmRvdmEgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9jb3Jkb3ZhXCIpO1xudmFyIGRldmljZSA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2RldmljZVwiKTtcbnZhciBkaSA9IHJlcXVpcmUoXCIuLy4uL2Rpc3QvZXM1L2RpXCIpO1xudmFyIHByb21pc2UgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9wcm9taXNlXCIpO1xudmFyIHN0b3JhZ2UgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS9zdG9yYWdlXCIpO1xudmFyIHVzZXIgPSByZXF1aXJlKFwiLi8uLi9kaXN0L2VzNS91c2VyL3VzZXJcIik7XG5cbi8vIERlY2xhcmUgdGhlIHdpbmRvdyBvYmplY3RcbndpbmRvdy5Jb25pYyA9IG5ldyBkaS5Db250YWluZXIoKTtcblxuLy8gSW9uaWMgTW9kdWxlc1xuSW9uaWMuQ29yZSA9IENvcmU7XG5Jb25pYy5Vc2VyID0gdXNlci5Vc2VyO1xuSW9uaWMuQXV0aCA9IGF1dGguQXV0aDtcbklvbmljLkRlcGxveSA9IERlcGxveTtcbklvbmljLlB1c2ggPSBQdXNoO1xuSW9uaWMuUHVzaE1lc3NhZ2UgPSBQdXNoTWVzc2FnZTtcblxuLy8gRGF0YVR5cGUgTmFtZXNwYWNlXG5Jb25pYy5EYXRhVHlwZSA9IERhdGFUeXBlO1xuSW9uaWMuRGF0YVR5cGVzID0gRGF0YVR5cGUuZ2V0TWFwcGluZygpO1xuXG4vLyBDbG91ZCBOYW1lc3BhY2VcbklvbmljLkNsb3VkID0ge307XG5Jb25pYy5DbG91ZC5BdXRoVHlwZSA9IGF1dGguQXV0aFR5cGU7XG5Jb25pYy5DbG91ZC5BdXRoVHlwZXMgPSB7fTtcbklvbmljLkNsb3VkLkF1dGhUeXBlcy5CYXNpY0F1dGggPSBhdXRoLkJhc2ljQXV0aDtcbklvbmljLkNsb3VkLkF1dGhUeXBlcy5DdXN0b21BdXRoID0gYXV0aC5DdXN0b21BdXRoO1xuSW9uaWMuQ2xvdWQuQXV0aFR5cGVzLlR3aXR0ZXJBdXRoID0gYXV0aC5Ud2l0dGVyQXV0aDtcbklvbmljLkNsb3VkLkF1dGhUeXBlcy5GYWNlYm9va0F1dGggPSBhdXRoLkZhY2Vib29rQXV0aDtcbklvbmljLkNsb3VkLkF1dGhUeXBlcy5HaXRodWJBdXRoID0gYXV0aC5HaXRodWJBdXRoO1xuSW9uaWMuQ2xvdWQuQXV0aFR5cGVzLkdvb2dsZUF1dGggPSBhdXRoLkdvb2dsZUF1dGg7XG5Jb25pYy5DbG91ZC5BdXRoVHlwZXMuSW5zdGFncmFtQXV0aCA9IGF1dGguSW5zdGFncmFtQXV0aDtcbklvbmljLkNsb3VkLkF1dGhUeXBlcy5MaW5rZWRJbkF1dGggPSBhdXRoLkxpbmtlZEluQXV0aDtcbklvbmljLkNsb3VkLkNvcmRvdmEgPSBjb3Jkb3ZhLkNvcmRvdmE7XG5Jb25pYy5DbG91ZC5DbGllbnQgPSBjbGllbnQuQ2xpZW50O1xuSW9uaWMuQ2xvdWQuRGV2aWNlID0gZGV2aWNlLkRldmljZTtcbklvbmljLkNsb3VkLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbklvbmljLkNsb3VkLkxvZ2dlciA9IExvZ2dlcjtcbklvbmljLkNsb3VkLkRlZmVycmVkUHJvbWlzZSA9IHByb21pc2UuRGVmZXJyZWRQcm9taXNlO1xuSW9uaWMuQ2xvdWQuU3RvcmFnZSA9IHN0b3JhZ2UuU3RvcmFnZTtcbklvbmljLkNsb3VkLlVzZXJDb250ZXh0ID0gdXNlci5Vc2VyQ29udGV4dDtcbklvbmljLkNsb3VkLlNpbmdsZVVzZXJTZXJ2aWNlID0gdXNlci5TaW5nbGVVc2VyU2VydmljZTtcbklvbmljLkNsb3VkLkF1dGhUb2tlbkNvbnRleHQgPSBhdXRoLkF1dGhUb2tlbkNvbnRleHQ7XG5Jb25pYy5DbG91ZC5Db21iaW5lZEF1dGhUb2tlbkNvbnRleHQgPSBhdXRoLkNvbWJpbmVkQXV0aFRva2VuQ29udGV4dDtcbklvbmljLkNsb3VkLkxvY2FsU3RvcmFnZVN0cmF0ZWd5ID0gc3RvcmFnZS5Mb2NhbFN0b3JhZ2VTdHJhdGVneTtcbklvbmljLkNsb3VkLlNlc3Npb25TdG9yYWdlU3RyYXRlZ3kgPSBzdG9yYWdlLlNlc3Npb25TdG9yYWdlU3RyYXRlZ3k7XG5Jb25pYy5DbG91ZC5Db25maWcgPSBjb25maWcuQ29uZmlnO1xuIl19
